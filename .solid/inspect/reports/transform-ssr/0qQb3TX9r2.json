{
  "resolvedId": "/home/yongqi/Repositories/yonggqiii.github.io/node_modules/solid-start/server/server-functions/server.ts",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { sharedConfig } from \"solid-js\";\nimport { internalFetch } from \"../../api/internalFetch\";\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  ResponseError,\n  XSolidStartContentTypeHeader,\n  XSolidStartLocationHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader,\n  isRedirectResponse\n} from \"../responses\";\nimport { PageEvent, ServerFunctionEvent } from \"../types\";\nimport { CreateServerFunction } from \"./types\";\nexport type { APIEvent } from \"../../api/types\";\n\nexport const server$: CreateServerFunction = ((_fn: any) => {\n  throw new Error(\"Should be compiled away\");\n}) as unknown as CreateServerFunction;\n\nasync function parseRequest(event: ServerFunctionEvent) {\n  let request = event.request;\n  let contentType = request.headers.get(ContentTypeHeader);\n  let name = new URL(request.url).pathname,\n    args = [];\n\n  if (contentType) {\n    if (contentType === JSONResponseType) {\n      let text = await request.text();\n      try {\n        args = JSON.parse(text, (key: string, value: any) => {\n          if (!value) {\n            return value;\n          }\n          if (value.$type === \"headers\") {\n            let headers = new Headers();\n            request.headers.forEach((value, key) => headers.set(key, value));\n            value.values.forEach(([key, value]: [string, any]) => headers.set(key, value));\n            return headers;\n          }\n          if (value.$type === \"request\") {\n            return new Request(value.url, {\n              method: value.method,\n              headers: value.headers\n            });\n          }\n          return value;\n        });\n      } catch (e) {\n        throw new Error(`Error parsing request body: ${text}`);\n      }\n    } else if (contentType.includes(\"form\")) {\n      let formData = await request.clone().formData();\n      args = [formData, event];\n    }\n  }\n  return [name, args] as const;\n}\n\nexport function respondWith(\n  request: Request,\n  data: Response | Error | FormError | string | object,\n  responseType: \"throw\" | \"return\"\n) {\n  if (data instanceof ResponseError) {\n    data = data.clone();\n  }\n\n  if (data instanceof Response) {\n    if (isRedirectResponse(data) && request.headers.get(XSolidStartOrigin) === \"client\") {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader)!);\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(null, {\n        status: 204,\n        statusText: \"Redirected\",\n        headers: headers\n      });\n    } else if (data.status === 101) {\n      // this is a websocket upgrade, so we don't want to modify the response\n      return data;\n    } else {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n\n      return new Response(data.body, {\n        status: data.status,\n        statusText: data.statusText,\n        headers\n      });\n    }\n  } else if (data instanceof FormError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV\n            ? `The stack for FormErrors are only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\\n\\n${data.stack}`\n            : \"\",\n          formError: data.formError,\n          fields: data.fields,\n          fieldErrors: data.fieldErrors\n        }\n      }),\n      {\n        status: 400,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"form-error\"\n        }\n      }\n    );\n  } else if (data instanceof ServerError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV\n            ? `The stack for ServerErrors is only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\\n\\n${data.stack}`\n            : \"\"\n        }\n      }),\n      {\n        status: data.status,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"server-error\"\n        }\n      }\n    );\n  } else if (data instanceof Error) {\n    console.error(data);\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: import.meta.env.DEV\n            ? `Internal Server Error (${data.message})`\n            : \"Internal Server Error\",\n          stack: import.meta.env.DEV\n            ? `This error happened inside a server function and you didn't handle it. So the client will receive an Internal Server Error. You can catch the error and throw a ServerError that makes sense for your UI. In production, the user will have no idea what the error is: \\n\\n${data.stack}`\n            : \"\",\n          status: (data as any).status\n        }\n      }),\n      {\n        status: (data as any).status || 500,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"error\"\n        }\n      }\n    );\n  } else if (\n    typeof data === \"object\" ||\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\"\n  ) {\n    return new Response(JSON.stringify(data), {\n      status: 200,\n      headers: {\n        [ContentTypeHeader]: \"application/json\",\n        [XSolidStartResponseTypeHeader]: responseType,\n        [XSolidStartContentTypeHeader]: \"json\"\n      }\n    });\n  }\n\n  return new Response(\"null\", {\n    status: 200,\n    headers: {\n      [ContentTypeHeader]: \"application/json\",\n      [XSolidStartContentTypeHeader]: \"json\",\n      [XSolidStartResponseTypeHeader]: responseType\n    }\n  });\n}\n\nexport async function handleServerRequest(event: ServerFunctionEvent) {\n  const url = new URL(event.request.url);\n\n  if (server$.hasHandler(url.pathname)) {\n    try {\n      let [name, args] = await parseRequest(event);\n      let handler = server$.getHandler(name);\n      if (!handler) {\n        throw {\n          status: 404,\n          message: \"Handler Not Found for \" + name\n        };\n      }\n      const data = await handler.call(event, ...(Array.isArray(args) ? args : [args]));\n      return respondWith(event.request, data, \"return\");\n    } catch (error) {\n      return respondWith(event.request, error as Error, \"throw\");\n    }\n  }\n\n  return null;\n}\n\nconst handlers = new Map();\n// server$.requestContext = null;\nserver$.createHandler = (_fn, hash, serverResource) => {\n  // this is run in two ways:\n  // called on the server while rendering the App, eg. in a routeData function\n  // - pass args as is to the fn, they should maintain identity since they are passed by reference\n  // - pass the response/throw the response, as you get it,\n  // - except when its a redirect and you are rendering the App,\n  //     - then we need to somehow communicate to the central server that this request is a redirect and should set the appropriate headers and status code\n  // called on the server when an HTTP request for this server function is made to the server (by a client)\n  // - request is parsed to figure out the args that need to be passed here, we still pass the same args as above, but they are not the same reference\n  //   as the ones passed in the client. They are cloned and serialized and made as similar to the ones passed in the client as possible\n  let fn: any = function (this: PageEvent | any, ...args: any[]) {\n    let ctx: any | undefined;\n\n    // if called with fn.call(...), we check if we got a valid RequestContext, and use that as\n    // the request context for this server function call\n    if (typeof this === \"object\") {\n      ctx = this;\n      // @ts-ignore\n    } else if (sharedConfig.context && sharedConfig.context.requestContext) {\n      // otherwise we check if the sharedConfig has a requestContext, and use that as the request context\n      // people shouldn't rely on this\n      // @ts-ignore\n      ctx = sharedConfig.context.requestContext;\n    } else {\n      // this is normally used during a test\n      ctx = {\n        request: new URL(hash, \"http://localhost:3000\").href,\n        responseHeaders: new Headers()\n      } as any;\n    }\n\n    const execute = async () => {\n      try {\n        return serverResource ? _fn.call(ctx, args[0], ctx) : _fn.call(ctx, ...args);\n      } catch (e) {\n        if (e instanceof Error && /[A-Za-z]+ is not defined/.test(e.message)) {\n          const error = new Error(\n            e.message +\n              \"\\n\" +\n              \" You probably are using a variable defined in a closure in your server function.\"\n          );\n          error.stack = e.stack;\n          throw error;\n        }\n        throw e;\n      }\n    };\n\n    return execute();\n  };\n\n  fn.url = hash;\n  fn.action = function (...args: any[]) {\n    return fn.call(this, ...args);\n  };\n\n  return fn;\n};\n\nserver$.registerHandler = function (route, handler) {\n  handlers.set(route, handler);\n};\n\nserver$.getHandler = function (route) {\n  return handlers.get(route);\n};\n\nserver$.hasHandler = function (route) {\n  return handlers.has(route);\n};\n\n// used to fetch from an API route on the server or client, without falling into\n// fetch problems on the server\nserver$.fetch = internalFetch;\n",
      "start": 1720885728696,
      "end": 1720885728696
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1720885728696,
      "end": 1720885728696,
      "order": "pre"
    },
    {
      "name": "solid",
      "start": 1720885728696,
      "end": 1720885728696,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1720885728696,
      "end": 1720885728696,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import { sharedConfig } from \"solid-js\";\nimport { internalFetch } from \"../../api/internalFetch\";\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  ResponseError,\n  XSolidStartContentTypeHeader,\n  XSolidStartLocationHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader,\n  isRedirectResponse\n} from \"../responses\";\nexport const server$ = (_fn) => {\n  throw new Error(\"Should be compiled away\");\n};\nasync function parseRequest(event) {\n  let request = event.request;\n  let contentType = request.headers.get(ContentTypeHeader);\n  let name = new URL(request.url).pathname, args = [];\n  if (contentType) {\n    if (contentType === JSONResponseType) {\n      let text = await request.text();\n      try {\n        args = JSON.parse(text, (key, value) => {\n          if (!value) {\n            return value;\n          }\n          if (value.$type === \"headers\") {\n            let headers = new Headers();\n            request.headers.forEach((value2, key2) => headers.set(key2, value2));\n            value.values.forEach(([key2, value2]) => headers.set(key2, value2));\n            return headers;\n          }\n          if (value.$type === \"request\") {\n            return new Request(value.url, {\n              method: value.method,\n              headers: value.headers\n            });\n          }\n          return value;\n        });\n      } catch (e) {\n        throw new Error(`Error parsing request body: ${text}`);\n      }\n    } else if (contentType.includes(\"form\")) {\n      let formData = await request.clone().formData();\n      args = [formData, event];\n    }\n  }\n  return [name, args];\n}\nexport function respondWith(request, data, responseType) {\n  if (data instanceof ResponseError) {\n    data = data.clone();\n  }\n  if (data instanceof Response) {\n    if (isRedirectResponse(data) && request.headers.get(XSolidStartOrigin) === \"client\") {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader));\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(null, {\n        status: 204,\n        statusText: \"Redirected\",\n        headers\n      });\n    } else if (data.status === 101) {\n      return data;\n    } else {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(data.body, {\n        status: data.status,\n        statusText: data.statusText,\n        headers\n      });\n    }\n  } else if (data instanceof FormError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV ? `The stack for FormErrors are only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\",\n          formError: data.formError,\n          fields: data.fields,\n          fieldErrors: data.fieldErrors\n        }\n      }),\n      {\n        status: 400,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"form-error\"\n        }\n      }\n    );\n  } else if (data instanceof ServerError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV ? `The stack for ServerErrors is only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\"\n        }\n      }),\n      {\n        status: data.status,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"server-error\"\n        }\n      }\n    );\n  } else if (data instanceof Error) {\n    console.error(data);\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: import.meta.env.DEV ? `Internal Server Error (${data.message})` : \"Internal Server Error\",\n          stack: import.meta.env.DEV ? `This error happened inside a server function and you didn't handle it. So the client will receive an Internal Server Error. You can catch the error and throw a ServerError that makes sense for your UI. In production, the user will have no idea what the error is: \n\n${data.stack}` : \"\",\n          status: data.status\n        }\n      }),\n      {\n        status: data.status || 500,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"error\"\n        }\n      }\n    );\n  } else if (typeof data === \"object\" || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\") {\n    return new Response(JSON.stringify(data), {\n      status: 200,\n      headers: {\n        [ContentTypeHeader]: \"application/json\",\n        [XSolidStartResponseTypeHeader]: responseType,\n        [XSolidStartContentTypeHeader]: \"json\"\n      }\n    });\n  }\n  return new Response(\"null\", {\n    status: 200,\n    headers: {\n      [ContentTypeHeader]: \"application/json\",\n      [XSolidStartContentTypeHeader]: \"json\",\n      [XSolidStartResponseTypeHeader]: responseType\n    }\n  });\n}\nexport async function handleServerRequest(event) {\n  const url = new URL(event.request.url);\n  if (server$.hasHandler(url.pathname)) {\n    try {\n      let [name, args] = await parseRequest(event);\n      let handler = server$.getHandler(name);\n      if (!handler) {\n        throw {\n          status: 404,\n          message: \"Handler Not Found for \" + name\n        };\n      }\n      const data = await handler.call(event, ...Array.isArray(args) ? args : [args]);\n      return respondWith(event.request, data, \"return\");\n    } catch (error) {\n      return respondWith(event.request, error, \"throw\");\n    }\n  }\n  return null;\n}\nconst handlers = /* @__PURE__ */ new Map();\nserver$.createHandler = (_fn, hash, serverResource) => {\n  let fn = function(...args) {\n    let ctx;\n    if (typeof this === \"object\") {\n      ctx = this;\n    } else if (sharedConfig.context && sharedConfig.context.requestContext) {\n      ctx = sharedConfig.context.requestContext;\n    } else {\n      ctx = {\n        request: new URL(hash, \"http://localhost:3000\").href,\n        responseHeaders: new Headers()\n      };\n    }\n    const execute = async () => {\n      try {\n        return serverResource ? _fn.call(ctx, args[0], ctx) : _fn.call(ctx, ...args);\n      } catch (e) {\n        if (e instanceof Error && /[A-Za-z]+ is not defined/.test(e.message)) {\n          const error = new Error(\n            e.message + \"\\n You probably are using a variable defined in a closure in your server function.\"\n          );\n          error.stack = e.stack;\n          throw error;\n        }\n        throw e;\n      }\n    };\n    return execute();\n  };\n  fn.url = hash;\n  fn.action = function(...args) {\n    return fn.call(this, ...args);\n  };\n  return fn;\n};\nserver$.registerHandler = function(route, handler) {\n  handlers.set(route, handler);\n};\nserver$.getHandler = function(route) {\n  return handlers.get(route);\n};\nserver$.hasHandler = function(route) {\n  return handlers.has(route);\n};\nserver$.fetch = internalFetch;\n",
      "start": 1720885728696,
      "end": 1720885728700,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "server.ts"
        ],
        "sourcesContent": [
          "import { sharedConfig } from \"solid-js\";\nimport { internalFetch } from \"../../api/internalFetch\";\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  ResponseError,\n  XSolidStartContentTypeHeader,\n  XSolidStartLocationHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader,\n  isRedirectResponse\n} from \"../responses\";\nimport { PageEvent, ServerFunctionEvent } from \"../types\";\nimport { CreateServerFunction } from \"./types\";\nexport type { APIEvent } from \"../../api/types\";\n\nexport const server$: CreateServerFunction = ((_fn: any) => {\n  throw new Error(\"Should be compiled away\");\n}) as unknown as CreateServerFunction;\n\nasync function parseRequest(event: ServerFunctionEvent) {\n  let request = event.request;\n  let contentType = request.headers.get(ContentTypeHeader);\n  let name = new URL(request.url).pathname,\n    args = [];\n\n  if (contentType) {\n    if (contentType === JSONResponseType) {\n      let text = await request.text();\n      try {\n        args = JSON.parse(text, (key: string, value: any) => {\n          if (!value) {\n            return value;\n          }\n          if (value.$type === \"headers\") {\n            let headers = new Headers();\n            request.headers.forEach((value, key) => headers.set(key, value));\n            value.values.forEach(([key, value]: [string, any]) => headers.set(key, value));\n            return headers;\n          }\n          if (value.$type === \"request\") {\n            return new Request(value.url, {\n              method: value.method,\n              headers: value.headers\n            });\n          }\n          return value;\n        });\n      } catch (e) {\n        throw new Error(`Error parsing request body: ${text}`);\n      }\n    } else if (contentType.includes(\"form\")) {\n      let formData = await request.clone().formData();\n      args = [formData, event];\n    }\n  }\n  return [name, args] as const;\n}\n\nexport function respondWith(\n  request: Request,\n  data: Response | Error | FormError | string | object,\n  responseType: \"throw\" | \"return\"\n) {\n  if (data instanceof ResponseError) {\n    data = data.clone();\n  }\n\n  if (data instanceof Response) {\n    if (isRedirectResponse(data) && request.headers.get(XSolidStartOrigin) === \"client\") {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader)!);\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(null, {\n        status: 204,\n        statusText: \"Redirected\",\n        headers: headers\n      });\n    } else if (data.status === 101) {\n      // this is a websocket upgrade, so we don't want to modify the response\n      return data;\n    } else {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n\n      return new Response(data.body, {\n        status: data.status,\n        statusText: data.statusText,\n        headers\n      });\n    }\n  } else if (data instanceof FormError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV\n            ? `The stack for FormErrors are only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\\n\\n${data.stack}`\n            : \"\",\n          formError: data.formError,\n          fields: data.fields,\n          fieldErrors: data.fieldErrors\n        }\n      }),\n      {\n        status: 400,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"form-error\"\n        }\n      }\n    );\n  } else if (data instanceof ServerError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV\n            ? `The stack for ServerErrors is only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\\n\\n${data.stack}`\n            : \"\"\n        }\n      }),\n      {\n        status: data.status,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"server-error\"\n        }\n      }\n    );\n  } else if (data instanceof Error) {\n    console.error(data);\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: import.meta.env.DEV\n            ? `Internal Server Error (${data.message})`\n            : \"Internal Server Error\",\n          stack: import.meta.env.DEV\n            ? `This error happened inside a server function and you didn't handle it. So the client will receive an Internal Server Error. You can catch the error and throw a ServerError that makes sense for your UI. In production, the user will have no idea what the error is: \\n\\n${data.stack}`\n            : \"\",\n          status: (data as any).status\n        }\n      }),\n      {\n        status: (data as any).status || 500,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"error\"\n        }\n      }\n    );\n  } else if (\n    typeof data === \"object\" ||\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\"\n  ) {\n    return new Response(JSON.stringify(data), {\n      status: 200,\n      headers: {\n        [ContentTypeHeader]: \"application/json\",\n        [XSolidStartResponseTypeHeader]: responseType,\n        [XSolidStartContentTypeHeader]: \"json\"\n      }\n    });\n  }\n\n  return new Response(\"null\", {\n    status: 200,\n    headers: {\n      [ContentTypeHeader]: \"application/json\",\n      [XSolidStartContentTypeHeader]: \"json\",\n      [XSolidStartResponseTypeHeader]: responseType\n    }\n  });\n}\n\nexport async function handleServerRequest(event: ServerFunctionEvent) {\n  const url = new URL(event.request.url);\n\n  if (server$.hasHandler(url.pathname)) {\n    try {\n      let [name, args] = await parseRequest(event);\n      let handler = server$.getHandler(name);\n      if (!handler) {\n        throw {\n          status: 404,\n          message: \"Handler Not Found for \" + name\n        };\n      }\n      const data = await handler.call(event, ...(Array.isArray(args) ? args : [args]));\n      return respondWith(event.request, data, \"return\");\n    } catch (error) {\n      return respondWith(event.request, error as Error, \"throw\");\n    }\n  }\n\n  return null;\n}\n\nconst handlers = new Map();\n// server$.requestContext = null;\nserver$.createHandler = (_fn, hash, serverResource) => {\n  // this is run in two ways:\n  // called on the server while rendering the App, eg. in a routeData function\n  // - pass args as is to the fn, they should maintain identity since they are passed by reference\n  // - pass the response/throw the response, as you get it,\n  // - except when its a redirect and you are rendering the App,\n  //     - then we need to somehow communicate to the central server that this request is a redirect and should set the appropriate headers and status code\n  // called on the server when an HTTP request for this server function is made to the server (by a client)\n  // - request is parsed to figure out the args that need to be passed here, we still pass the same args as above, but they are not the same reference\n  //   as the ones passed in the client. They are cloned and serialized and made as similar to the ones passed in the client as possible\n  let fn: any = function (this: PageEvent | any, ...args: any[]) {\n    let ctx: any | undefined;\n\n    // if called with fn.call(...), we check if we got a valid RequestContext, and use that as\n    // the request context for this server function call\n    if (typeof this === \"object\") {\n      ctx = this;\n      // @ts-ignore\n    } else if (sharedConfig.context && sharedConfig.context.requestContext) {\n      // otherwise we check if the sharedConfig has a requestContext, and use that as the request context\n      // people shouldn't rely on this\n      // @ts-ignore\n      ctx = sharedConfig.context.requestContext;\n    } else {\n      // this is normally used during a test\n      ctx = {\n        request: new URL(hash, \"http://localhost:3000\").href,\n        responseHeaders: new Headers()\n      } as any;\n    }\n\n    const execute = async () => {\n      try {\n        return serverResource ? _fn.call(ctx, args[0], ctx) : _fn.call(ctx, ...args);\n      } catch (e) {\n        if (e instanceof Error && /[A-Za-z]+ is not defined/.test(e.message)) {\n          const error = new Error(\n            e.message +\n              \"\\n\" +\n              \" You probably are using a variable defined in a closure in your server function.\"\n          );\n          error.stack = e.stack;\n          throw error;\n        }\n        throw e;\n      }\n    };\n\n    return execute();\n  };\n\n  fn.url = hash;\n  fn.action = function (...args: any[]) {\n    return fn.call(this, ...args);\n  };\n\n  return fn;\n};\n\nserver$.registerHandler = function (route, handler) {\n  handlers.set(route, handler);\n};\n\nserver$.getHandler = function (route) {\n  return handlers.get(route);\n};\n\nserver$.hasHandler = function (route) {\n  return handlers.has(route);\n};\n\n// used to fetch from an API route on the server or client, without falling into\n// fetch problems on the server\nserver$.fetch = internalFetch;\n"
        ],
        "mappings": "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",
        "names": [
          "value",
          "key"
        ],
        "x_google_ignoreList": [
          0
        ]
      }
    },
    {
      "name": "vite:json",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { sharedConfig } from \"solid-js\";\nimport { internalFetch } from \"../../api/internalFetch\";\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  ResponseError,\n  XSolidStartContentTypeHeader,\n  XSolidStartLocationHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader,\n  isRedirectResponse\n} from \"../responses\";\nexport const server$ = (_fn) => {\n  throw new Error(\"Should be compiled away\");\n};\nasync function parseRequest(event) {\n  let request = event.request;\n  let contentType = request.headers.get(ContentTypeHeader);\n  let name = new URL(request.url).pathname, args = [];\n  if (contentType) {\n    if (contentType === JSONResponseType) {\n      let text = await request.text();\n      try {\n        args = JSON.parse(text, (key, value) => {\n          if (!value) {\n            return value;\n          }\n          if (value.$type === \"headers\") {\n            let headers = new Headers();\n            request.headers.forEach((value2, key2) => headers.set(key2, value2));\n            value.values.forEach(([key2, value2]) => headers.set(key2, value2));\n            return headers;\n          }\n          if (value.$type === \"request\") {\n            return new Request(value.url, {\n              method: value.method,\n              headers: value.headers\n            });\n          }\n          return value;\n        });\n      } catch (e) {\n        throw new Error(`Error parsing request body: ${text}`);\n      }\n    } else if (contentType.includes(\"form\")) {\n      let formData = await request.clone().formData();\n      args = [formData, event];\n    }\n  }\n  return [name, args];\n}\nexport function respondWith(request, data, responseType) {\n  if (data instanceof ResponseError) {\n    data = data.clone();\n  }\n  if (data instanceof Response) {\n    if (isRedirectResponse(data) && request.headers.get(XSolidStartOrigin) === \"client\") {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader));\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(null, {\n        status: 204,\n        statusText: \"Redirected\",\n        headers\n      });\n    } else if (data.status === 101) {\n      return data;\n    } else {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(data.body, {\n        status: data.status,\n        statusText: data.statusText,\n        headers\n      });\n    }\n  } else if (data instanceof FormError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV ? `The stack for FormErrors are only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\",\n          formError: data.formError,\n          fields: data.fields,\n          fieldErrors: data.fieldErrors\n        }\n      }),\n      {\n        status: 400,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"form-error\"\n        }\n      }\n    );\n  } else if (data instanceof ServerError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV ? `The stack for ServerErrors is only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\"\n        }\n      }),\n      {\n        status: data.status,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"server-error\"\n        }\n      }\n    );\n  } else if (data instanceof Error) {\n    console.error(data);\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: import.meta.env.DEV ? `Internal Server Error (${data.message})` : \"Internal Server Error\",\n          stack: import.meta.env.DEV ? `This error happened inside a server function and you didn't handle it. So the client will receive an Internal Server Error. You can catch the error and throw a ServerError that makes sense for your UI. In production, the user will have no idea what the error is: \n\n${data.stack}` : \"\",\n          status: data.status\n        }\n      }),\n      {\n        status: data.status || 500,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"error\"\n        }\n      }\n    );\n  } else if (typeof data === \"object\" || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\") {\n    return new Response(JSON.stringify(data), {\n      status: 200,\n      headers: {\n        [ContentTypeHeader]: \"application/json\",\n        [XSolidStartResponseTypeHeader]: responseType,\n        [XSolidStartContentTypeHeader]: \"json\"\n      }\n    });\n  }\n  return new Response(\"null\", {\n    status: 200,\n    headers: {\n      [ContentTypeHeader]: \"application/json\",\n      [XSolidStartContentTypeHeader]: \"json\",\n      [XSolidStartResponseTypeHeader]: responseType\n    }\n  });\n}\nexport async function handleServerRequest(event) {\n  const url = new URL(event.request.url);\n  if (server$.hasHandler(url.pathname)) {\n    try {\n      let [name, args] = await parseRequest(event);\n      let handler = server$.getHandler(name);\n      if (!handler) {\n        throw {\n          status: 404,\n          message: \"Handler Not Found for \" + name\n        };\n      }\n      const data = await handler.call(event, ...Array.isArray(args) ? args : [args]);\n      return respondWith(event.request, data, \"return\");\n    } catch (error) {\n      return respondWith(event.request, error, \"throw\");\n    }\n  }\n  return null;\n}\nconst handlers = /* @__PURE__ */ new Map();\nserver$.createHandler = (_fn, hash, serverResource) => {\n  let fn = function(...args) {\n    let ctx;\n    if (typeof this === \"object\") {\n      ctx = this;\n    } else if (sharedConfig.context && sharedConfig.context.requestContext) {\n      ctx = sharedConfig.context.requestContext;\n    } else {\n      ctx = {\n        request: new URL(hash, \"http://localhost:3000\").href,\n        responseHeaders: new Headers()\n      };\n    }\n    const execute = async () => {\n      try {\n        return serverResource ? _fn.call(ctx, args[0], ctx) : _fn.call(ctx, ...args);\n      } catch (e) {\n        if (e instanceof Error && /[A-Za-z]+ is not defined/.test(e.message)) {\n          const error = new Error(\n            e.message + \"\\n You probably are using a variable defined in a closure in your server function.\"\n          );\n          error.stack = e.stack;\n          throw error;\n        }\n        throw e;\n      }\n    };\n    return execute();\n  };\n  fn.url = hash;\n  fn.action = function(...args) {\n    return fn.call(this, ...args);\n  };\n  return fn;\n};\nserver$.registerHandler = function(route, handler) {\n  handlers.set(route, handler);\n};\nserver$.getHandler = function(route) {\n  return handlers.get(route);\n};\nserver$.hasHandler = function(route) {\n  return handlers.has(route);\n};\nserver$.fetch = internalFetch;\n",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import.meta.env = {\"BASE_URL\":\"/\",\"MODE\":\"development\",\"DEV\":true,\"PROD\":false,\"SSR\":true};import.meta.env.START_SSR = true;import.meta.env.START_ISLANDS = false;import.meta.env.START_ENTRY_CLIENT = \"/home/yongqi/Repositories/yonggqiii.github.io/src/entry-client.tsx\";import.meta.env.START_ENTRY_SERVER = \"/home/yongqi/Repositories/yonggqiii.github.io/src/entry-server.tsx\";import.meta.env.START_INDEX_HTML = false;import.meta.env.START_ISLANDS_ROUTER = false;import.meta.env.START_ADAPTER = \"static\";import { sharedConfig } from \"solid-js\";\nimport { internalFetch } from \"/node_modules/solid-start/api/internalFetch.ts\";\nimport { FormError } from \"/node_modules/solid-start/data/index.ts\";\nimport { ServerError } from \"/node_modules/solid-start/data/FormError.tsx\";\nimport {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  ResponseError,\n  XSolidStartContentTypeHeader,\n  XSolidStartLocationHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader,\n  isRedirectResponse\n} from \"/node_modules/solid-start/server/responses.ts\";\nexport const server$ = (_fn) => {\n  throw new Error(\"Should be compiled away\");\n};\nasync function parseRequest(event) {\n  let request = event.request;\n  let contentType = request.headers.get(ContentTypeHeader);\n  let name = new URL(request.url).pathname, args = [];\n  if (contentType) {\n    if (contentType === JSONResponseType) {\n      let text = await request.text();\n      try {\n        args = JSON.parse(text, (key, value) => {\n          if (!value) {\n            return value;\n          }\n          if (value.$type === \"headers\") {\n            let headers = new Headers();\n            request.headers.forEach((value2, key2) => headers.set(key2, value2));\n            value.values.forEach(([key2, value2]) => headers.set(key2, value2));\n            return headers;\n          }\n          if (value.$type === \"request\") {\n            return new Request(value.url, {\n              method: value.method,\n              headers: value.headers\n            });\n          }\n          return value;\n        });\n      } catch (e) {\n        throw new Error(`Error parsing request body: ${text}`);\n      }\n    } else if (contentType.includes(\"form\")) {\n      let formData = await request.clone().formData();\n      args = [formData, event];\n    }\n  }\n  return [name, args];\n}\nexport function respondWith(request, data, responseType) {\n  if (data instanceof ResponseError) {\n    data = data.clone();\n  }\n  if (data instanceof Response) {\n    if (isRedirectResponse(data) && request.headers.get(XSolidStartOrigin) === \"client\") {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader));\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(null, {\n        status: 204,\n        statusText: \"Redirected\",\n        headers\n      });\n    } else if (data.status === 101) {\n      return data;\n    } else {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(data.body, {\n        status: data.status,\n        statusText: data.statusText,\n        headers\n      });\n    }\n  } else if (data instanceof FormError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV ? `The stack for FormErrors are only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\",\n          formError: data.formError,\n          fields: data.fields,\n          fieldErrors: data.fieldErrors\n        }\n      }),\n      {\n        status: 400,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"form-error\"\n        }\n      }\n    );\n  } else if (data instanceof ServerError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV ? `The stack for ServerErrors is only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\"\n        }\n      }),\n      {\n        status: data.status,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"server-error\"\n        }\n      }\n    );\n  } else if (data instanceof Error) {\n    console.error(data);\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: import.meta.env.DEV ? `Internal Server Error (${data.message})` : \"Internal Server Error\",\n          stack: import.meta.env.DEV ? `This error happened inside a server function and you didn't handle it. So the client will receive an Internal Server Error. You can catch the error and throw a ServerError that makes sense for your UI. In production, the user will have no idea what the error is: \n\n${data.stack}` : \"\",\n          status: data.status\n        }\n      }),\n      {\n        status: data.status || 500,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"error\"\n        }\n      }\n    );\n  } else if (typeof data === \"object\" || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\") {\n    return new Response(JSON.stringify(data), {\n      status: 200,\n      headers: {\n        [ContentTypeHeader]: \"application/json\",\n        [XSolidStartResponseTypeHeader]: responseType,\n        [XSolidStartContentTypeHeader]: \"json\"\n      }\n    });\n  }\n  return new Response(\"null\", {\n    status: 200,\n    headers: {\n      [ContentTypeHeader]: \"application/json\",\n      [XSolidStartContentTypeHeader]: \"json\",\n      [XSolidStartResponseTypeHeader]: responseType\n    }\n  });\n}\nexport async function handleServerRequest(event) {\n  const url = new URL(event.request.url);\n  if (server$.hasHandler(url.pathname)) {\n    try {\n      let [name, args] = await parseRequest(event);\n      let handler = server$.getHandler(name);\n      if (!handler) {\n        throw {\n          status: 404,\n          message: \"Handler Not Found for \" + name\n        };\n      }\n      const data = await handler.call(event, ...Array.isArray(args) ? args : [args]);\n      return respondWith(event.request, data, \"return\");\n    } catch (error) {\n      return respondWith(event.request, error, \"throw\");\n    }\n  }\n  return null;\n}\nconst handlers = /* @__PURE__ */ new Map();\nserver$.createHandler = (_fn, hash, serverResource) => {\n  let fn = function(...args) {\n    let ctx;\n    if (typeof this === \"object\") {\n      ctx = this;\n    } else if (sharedConfig.context && sharedConfig.context.requestContext) {\n      ctx = sharedConfig.context.requestContext;\n    } else {\n      ctx = {\n        request: new URL(hash, \"http://localhost:3000\").href,\n        responseHeaders: new Headers()\n      };\n    }\n    const execute = async () => {\n      try {\n        return serverResource ? _fn.call(ctx, args[0], ctx) : _fn.call(ctx, ...args);\n      } catch (e) {\n        if (e instanceof Error && /[A-Za-z]+ is not defined/.test(e.message)) {\n          const error = new Error(\n            e.message + \"\\n You probably are using a variable defined in a closure in your server function.\"\n          );\n          error.stack = e.stack;\n          throw error;\n        }\n        throw e;\n      }\n    };\n    return execute();\n  };\n  fn.url = hash;\n  fn.action = function(...args) {\n    return fn.call(this, ...args);\n  };\n  return fn;\n};\nserver$.registerHandler = function(route, handler) {\n  handlers.set(route, handler);\n};\nserver$.getHandler = function(route) {\n  return handlers.get(route);\n};\nserver$.hasHandler = function(route) {\n  return handlers.has(route);\n};\nserver$.fetch = internalFetch;\n",
      "start": 1720885728700,
      "end": 1720885728700,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
