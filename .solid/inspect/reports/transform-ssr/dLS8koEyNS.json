{
  "resolvedId": "/home/yongqi/Repositories/yonggqiii.github.io/node_modules/solid-start/entry-server/render.ts",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { JSX } from \"solid-js\";\nimport { renderToStream, renderToString, renderToStringAsync } from \"solid-js/web\";\nimport { internalFetch } from \"../api/internalFetch\";\nimport { apiRoutes } from \"../api/middleware\";\nimport { inlineServerFunctions } from \"../server/middleware\";\nimport { redirect } from \"../server/responses\";\nimport { FetchEvent, FETCH_EVENT, PageEvent } from \"../server/types\";\n\nexport function renderSync(\n  fn: (context: PageEvent) => JSX.Element,\n  options?: {\n    nonce?: string;\n    renderId?: string;\n  }\n) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event: FetchEvent): Promise<Response> {\n        if (\n          !import.meta.env.DEV &&\n          !import.meta.env.START_SSR &&\n          !import.meta.env.START_INDEX_HTML\n        ) {\n          return await (\n            event as unknown as { env: { getStaticHTML(url: string | URL): Promise<Response> } }\n          ).env.getStaticHTML(\"/index\");\n        }\n\n        let pageEvent = createPageEvent(event);\n\n        let markup = renderToString(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n\n        markup = handleIslandsRouting(pageEvent, markup);\n\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\n\nexport function renderAsync(\n  fn: (context: PageEvent) => JSX.Element,\n  options?: {\n    timeoutMs?: number;\n    nonce?: string;\n    renderId?: string;\n  }\n) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event: FetchEvent): Promise<Response> {\n        if (\n          !import.meta.env.DEV &&\n          !import.meta.env.START_SSR &&\n          !import.meta.env.START_INDEX_HTML\n        ) {\n          const getStaticHTML = (\n            event as unknown as { env: { getStaticHTML(url: string | URL): Promise<Response> } }\n          ).env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n\n        let pageEvent = createPageEvent(event);\n\n        let markup = await renderToStringAsync(() => fn(pageEvent), options);\n\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          }) as Response;\n        }\n\n        markup = handleIslandsRouting(pageEvent, markup);\n\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\n\nexport function renderStream(\n  fn: (context: PageEvent) => JSX.Element,\n  baseOptions: {\n    nonce?: string;\n    renderId?: string;\n    onCompleteShell?: (info: { write: (v: string) => void }) => void;\n    onCompleteAll?: (info: { write: (v: string) => void }) => void;\n  } = {}\n) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event: FetchEvent): Promise<Response> {\n        if (\n          !import.meta.env.DEV &&\n          !import.meta.env.START_SSR &&\n          !import.meta.env.START_INDEX_HTML\n        ) {\n          const getStaticHTML = (\n            event as unknown as { env: { getStaticHTML(url: string | URL): Promise<Response> } }\n          ).env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n\n        let pageEvent = createPageEvent(event);\n\n        // Hijack after navigation with islands router to be async\n        // Todo streaming into HTML\n        if (import.meta.env.START_ISLANDS_ROUTER && event.request.headers.get(\"x-solid-referrer\")) {\n          let markup = await renderToStringAsync(() => fn(pageEvent), baseOptions);\n\n          if (pageEvent.routerContext && pageEvent.routerContext.url) {\n            return redirect(pageEvent.routerContext.url, {\n              headers: pageEvent.responseHeaders\n            }) as Response;\n          }\n\n          markup = handleIslandsRouting(pageEvent, markup);\n\n          return new Response(markup, {\n            status: pageEvent.getStatusCode(),\n            headers: pageEvent.responseHeaders\n          });\n        }\n\n        const options = { ...baseOptions };\n        if (options.onCompleteAll) {\n          const og = options.onCompleteAll;\n          options.onCompleteAll = options => {\n            handleStreamingRedirect(pageEvent)(options);\n            og(options);\n          };\n        } else options.onCompleteAll = handleStreamingRedirect(pageEvent);\n        const { readable, writable } = new TransformStream();\n        const stream = renderToStream(() => fn(pageEvent), options);\n\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n\n        handleStreamingIslandsRouting(pageEvent, writable);\n\n        stream.pipeTo(writable);\n\n        return new Response(readable, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\n\nfunction handleStreamingIslandsRouting(pageEvent: PageEvent, writable: WritableStream<any>) {\n  if (pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    writer.write(\n      encoder.encode(\n        `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=`\n      )\n    );\n    writer.releaseLock();\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n}\n\nfunction handleStreamingRedirect(context: PageEvent) {\n  return ({ write }: { write: (html: string) => void }) => {\n    if (context.routerContext && context.routerContext.url)\n      write(`<script>window.location=\"${context.routerContext.url}\"</script>`);\n  };\n}\n\nfunction createPageEvent(event: FetchEvent) {\n  let responseHeaders = new Headers({\n    \"Content-Type\": \"text/html\"\n  });\n\n  const prevPath = event.request.headers.get(\"x-solid-referrer\");\n\n  let statusCode = 200;\n\n  function setStatusCode(code: number) {\n    statusCode = code;\n  }\n\n  function getStatusCode() {\n    return statusCode;\n  }\n\n  const pageEvent: PageEvent = Object.freeze({\n    request: event.request,\n    prevUrl: prevPath || \"\",\n    routerContext: {},\n    tags: [],\n    env: event.env,\n    clientAddress: event.clientAddress,\n    locals: event.locals,\n    $type: FETCH_EVENT,\n    responseHeaders,\n    setStatusCode: setStatusCode,\n    getStatusCode: getStatusCode,\n    fetch: internalFetch\n  });\n\n  return pageEvent;\n}\n\nfunction handleIslandsRouting(pageEvent: PageEvent, markup: string) {\n  if (\n    import.meta.env.START_ISLANDS_ROUTER &&\n    pageEvent.routerContext &&\n    pageEvent.routerContext.replaceOutletId\n  ) {\n    markup = `${pageEvent.routerContext.replaceOutletId}:${\n      pageEvent.routerContext.newOutletId\n    }=${markup.slice(\n      markup.indexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) +\n        `<!--${pageEvent.routerContext.newOutletId}-->`.length +\n        `<outlet-wrapper id=\"${pageEvent.routerContext.newOutletId}\">`.length,\n      markup.lastIndexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) -\n        `</outlet-wrapper>`.length\n    )}`;\n\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n  return markup;\n}\n",
      "start": 1702914706636,
      "end": 1702914706636
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1702914706636,
      "end": 1702914706637,
      "order": "pre"
    },
    {
      "name": "solid",
      "start": 1702914706637,
      "end": 1702914706637,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1702914706637,
      "end": 1702914706637,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import { renderToStream, renderToString, renderToStringAsync } from \"solid-js/web\";\nimport { internalFetch } from \"../api/internalFetch\";\nimport { apiRoutes } from \"../api/middleware\";\nimport { inlineServerFunctions } from \"../server/middleware\";\nimport { redirect } from \"../server/responses\";\nimport { FETCH_EVENT } from \"../server/types\";\nexport function renderSync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !import.meta.env.START_SSR && !import.meta.env.START_INDEX_HTML) {\n          return await event.env.getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = renderToString(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderAsync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !import.meta.env.START_SSR && !import.meta.env.START_INDEX_HTML) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = await renderToStringAsync(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderStream(fn, baseOptions = {}) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !import.meta.env.START_SSR && !import.meta.env.START_INDEX_HTML) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        if (import.meta.env.START_ISLANDS_ROUTER && event.request.headers.get(\"x-solid-referrer\")) {\n          let markup = await renderToStringAsync(() => fn(pageEvent), baseOptions);\n          if (pageEvent.routerContext && pageEvent.routerContext.url) {\n            return redirect(pageEvent.routerContext.url, {\n              headers: pageEvent.responseHeaders\n            });\n          }\n          markup = handleIslandsRouting(pageEvent, markup);\n          return new Response(markup, {\n            status: pageEvent.getStatusCode(),\n            headers: pageEvent.responseHeaders\n          });\n        }\n        const options = { ...baseOptions };\n        if (options.onCompleteAll) {\n          const og = options.onCompleteAll;\n          options.onCompleteAll = (options2) => {\n            handleStreamingRedirect(pageEvent)(options2);\n            og(options2);\n          };\n        } else\n          options.onCompleteAll = handleStreamingRedirect(pageEvent);\n        const { readable, writable } = new TransformStream();\n        const stream = renderToStream(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        handleStreamingIslandsRouting(pageEvent, writable);\n        stream.pipeTo(writable);\n        return new Response(readable, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nfunction handleStreamingIslandsRouting(pageEvent, writable) {\n  if (pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    writer.write(\n      encoder.encode(\n        `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=`\n      )\n    );\n    writer.releaseLock();\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n}\nfunction handleStreamingRedirect(context) {\n  return ({ write }) => {\n    if (context.routerContext && context.routerContext.url)\n      write(`<script>window.location=\"${context.routerContext.url}\"<\\/script>`);\n  };\n}\nfunction createPageEvent(event) {\n  let responseHeaders = new Headers({\n    \"Content-Type\": \"text/html\"\n  });\n  const prevPath = event.request.headers.get(\"x-solid-referrer\");\n  let statusCode = 200;\n  function setStatusCode(code) {\n    statusCode = code;\n  }\n  function getStatusCode() {\n    return statusCode;\n  }\n  const pageEvent = Object.freeze({\n    request: event.request,\n    prevUrl: prevPath || \"\",\n    routerContext: {},\n    tags: [],\n    env: event.env,\n    clientAddress: event.clientAddress,\n    locals: event.locals,\n    $type: FETCH_EVENT,\n    responseHeaders,\n    setStatusCode,\n    getStatusCode,\n    fetch: internalFetch\n  });\n  return pageEvent;\n}\nfunction handleIslandsRouting(pageEvent, markup) {\n  if (import.meta.env.START_ISLANDS_ROUTER && pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    markup = `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=${markup.slice(\n      markup.indexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) + `<!--${pageEvent.routerContext.newOutletId}-->`.length + `<outlet-wrapper id=\"${pageEvent.routerContext.newOutletId}\">`.length,\n      markup.lastIndexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) - `</outlet-wrapper>`.length\n    )}`;\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n  return markup;\n}\n",
      "start": 1702914706637,
      "end": 1702914706706,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "render.ts"
        ],
        "sourcesContent": [
          "import { JSX } from \"solid-js\";\nimport { renderToStream, renderToString, renderToStringAsync } from \"solid-js/web\";\nimport { internalFetch } from \"../api/internalFetch\";\nimport { apiRoutes } from \"../api/middleware\";\nimport { inlineServerFunctions } from \"../server/middleware\";\nimport { redirect } from \"../server/responses\";\nimport { FetchEvent, FETCH_EVENT, PageEvent } from \"../server/types\";\n\nexport function renderSync(\n  fn: (context: PageEvent) => JSX.Element,\n  options?: {\n    nonce?: string;\n    renderId?: string;\n  }\n) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event: FetchEvent): Promise<Response> {\n        if (\n          !import.meta.env.DEV &&\n          !import.meta.env.START_SSR &&\n          !import.meta.env.START_INDEX_HTML\n        ) {\n          return await (\n            event as unknown as { env: { getStaticHTML(url: string | URL): Promise<Response> } }\n          ).env.getStaticHTML(\"/index\");\n        }\n\n        let pageEvent = createPageEvent(event);\n\n        let markup = renderToString(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n\n        markup = handleIslandsRouting(pageEvent, markup);\n\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\n\nexport function renderAsync(\n  fn: (context: PageEvent) => JSX.Element,\n  options?: {\n    timeoutMs?: number;\n    nonce?: string;\n    renderId?: string;\n  }\n) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event: FetchEvent): Promise<Response> {\n        if (\n          !import.meta.env.DEV &&\n          !import.meta.env.START_SSR &&\n          !import.meta.env.START_INDEX_HTML\n        ) {\n          const getStaticHTML = (\n            event as unknown as { env: { getStaticHTML(url: string | URL): Promise<Response> } }\n          ).env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n\n        let pageEvent = createPageEvent(event);\n\n        let markup = await renderToStringAsync(() => fn(pageEvent), options);\n\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          }) as Response;\n        }\n\n        markup = handleIslandsRouting(pageEvent, markup);\n\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\n\nexport function renderStream(\n  fn: (context: PageEvent) => JSX.Element,\n  baseOptions: {\n    nonce?: string;\n    renderId?: string;\n    onCompleteShell?: (info: { write: (v: string) => void }) => void;\n    onCompleteAll?: (info: { write: (v: string) => void }) => void;\n  } = {}\n) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event: FetchEvent): Promise<Response> {\n        if (\n          !import.meta.env.DEV &&\n          !import.meta.env.START_SSR &&\n          !import.meta.env.START_INDEX_HTML\n        ) {\n          const getStaticHTML = (\n            event as unknown as { env: { getStaticHTML(url: string | URL): Promise<Response> } }\n          ).env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n\n        let pageEvent = createPageEvent(event);\n\n        // Hijack after navigation with islands router to be async\n        // Todo streaming into HTML\n        if (import.meta.env.START_ISLANDS_ROUTER && event.request.headers.get(\"x-solid-referrer\")) {\n          let markup = await renderToStringAsync(() => fn(pageEvent), baseOptions);\n\n          if (pageEvent.routerContext && pageEvent.routerContext.url) {\n            return redirect(pageEvent.routerContext.url, {\n              headers: pageEvent.responseHeaders\n            }) as Response;\n          }\n\n          markup = handleIslandsRouting(pageEvent, markup);\n\n          return new Response(markup, {\n            status: pageEvent.getStatusCode(),\n            headers: pageEvent.responseHeaders\n          });\n        }\n\n        const options = { ...baseOptions };\n        if (options.onCompleteAll) {\n          const og = options.onCompleteAll;\n          options.onCompleteAll = options => {\n            handleStreamingRedirect(pageEvent)(options);\n            og(options);\n          };\n        } else options.onCompleteAll = handleStreamingRedirect(pageEvent);\n        const { readable, writable } = new TransformStream();\n        const stream = renderToStream(() => fn(pageEvent), options);\n\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n\n        handleStreamingIslandsRouting(pageEvent, writable);\n\n        stream.pipeTo(writable);\n\n        return new Response(readable, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\n\nfunction handleStreamingIslandsRouting(pageEvent: PageEvent, writable: WritableStream<any>) {\n  if (pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    writer.write(\n      encoder.encode(\n        `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=`\n      )\n    );\n    writer.releaseLock();\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n}\n\nfunction handleStreamingRedirect(context: PageEvent) {\n  return ({ write }: { write: (html: string) => void }) => {\n    if (context.routerContext && context.routerContext.url)\n      write(`<script>window.location=\"${context.routerContext.url}\"</script>`);\n  };\n}\n\nfunction createPageEvent(event: FetchEvent) {\n  let responseHeaders = new Headers({\n    \"Content-Type\": \"text/html\"\n  });\n\n  const prevPath = event.request.headers.get(\"x-solid-referrer\");\n\n  let statusCode = 200;\n\n  function setStatusCode(code: number) {\n    statusCode = code;\n  }\n\n  function getStatusCode() {\n    return statusCode;\n  }\n\n  const pageEvent: PageEvent = Object.freeze({\n    request: event.request,\n    prevUrl: prevPath || \"\",\n    routerContext: {},\n    tags: [],\n    env: event.env,\n    clientAddress: event.clientAddress,\n    locals: event.locals,\n    $type: FETCH_EVENT,\n    responseHeaders,\n    setStatusCode: setStatusCode,\n    getStatusCode: getStatusCode,\n    fetch: internalFetch\n  });\n\n  return pageEvent;\n}\n\nfunction handleIslandsRouting(pageEvent: PageEvent, markup: string) {\n  if (\n    import.meta.env.START_ISLANDS_ROUTER &&\n    pageEvent.routerContext &&\n    pageEvent.routerContext.replaceOutletId\n  ) {\n    markup = `${pageEvent.routerContext.replaceOutletId}:${\n      pageEvent.routerContext.newOutletId\n    }=${markup.slice(\n      markup.indexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) +\n        `<!--${pageEvent.routerContext.newOutletId}-->`.length +\n        `<outlet-wrapper id=\"${pageEvent.routerContext.newOutletId}\">`.length,\n      markup.lastIndexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) -\n        `</outlet-wrapper>`.length\n    )}`;\n\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n  return markup;\n}\n"
        ],
        "mappings": "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",
        "names": [
          "options"
        ],
        "x_google_ignoreList": [
          0
        ]
      }
    },
    {
      "name": "vite:json",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { renderToStream, renderToString, renderToStringAsync } from \"solid-js/web\";\nimport { internalFetch } from \"../api/internalFetch\";\nimport { apiRoutes } from \"../api/middleware\";\nimport { inlineServerFunctions } from \"../server/middleware\";\nimport { redirect } from \"../server/responses\";\nimport { FETCH_EVENT } from \"../server/types\";\nexport function renderSync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          return await event.env.getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = renderToString(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderAsync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = await renderToStringAsync(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderStream(fn, baseOptions = {}) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        if (false && event.request.headers.get(\"x-solid-referrer\")) {\n          let markup = await renderToStringAsync(() => fn(pageEvent), baseOptions);\n          if (pageEvent.routerContext && pageEvent.routerContext.url) {\n            return redirect(pageEvent.routerContext.url, {\n              headers: pageEvent.responseHeaders\n            });\n          }\n          markup = handleIslandsRouting(pageEvent, markup);\n          return new Response(markup, {\n            status: pageEvent.getStatusCode(),\n            headers: pageEvent.responseHeaders\n          });\n        }\n        const options = { ...baseOptions };\n        if (options.onCompleteAll) {\n          const og = options.onCompleteAll;\n          options.onCompleteAll = (options2) => {\n            handleStreamingRedirect(pageEvent)(options2);\n            og(options2);\n          };\n        } else\n          options.onCompleteAll = handleStreamingRedirect(pageEvent);\n        const { readable, writable } = new TransformStream();\n        const stream = renderToStream(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        handleStreamingIslandsRouting(pageEvent, writable);\n        stream.pipeTo(writable);\n        return new Response(readable, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nfunction handleStreamingIslandsRouting(pageEvent, writable) {\n  if (pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    writer.write(\n      encoder.encode(\n        `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=`\n      )\n    );\n    writer.releaseLock();\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n}\nfunction handleStreamingRedirect(context) {\n  return ({ write }) => {\n    if (context.routerContext && context.routerContext.url)\n      write(`<script>window.location=\"${context.routerContext.url}\"<\\/script>`);\n  };\n}\nfunction createPageEvent(event) {\n  let responseHeaders = new Headers({\n    \"Content-Type\": \"text/html\"\n  });\n  const prevPath = event.request.headers.get(\"x-solid-referrer\");\n  let statusCode = 200;\n  function setStatusCode(code) {\n    statusCode = code;\n  }\n  function getStatusCode() {\n    return statusCode;\n  }\n  const pageEvent = Object.freeze({\n    request: event.request,\n    prevUrl: prevPath || \"\",\n    routerContext: {},\n    tags: [],\n    env: event.env,\n    clientAddress: event.clientAddress,\n    locals: event.locals,\n    $type: FETCH_EVENT,\n    responseHeaders,\n    setStatusCode,\n    getStatusCode,\n    fetch: internalFetch\n  });\n  return pageEvent;\n}\nfunction handleIslandsRouting(pageEvent, markup) {\n  if (false && pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    markup = `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=${markup.slice(\n      markup.indexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) + `<!--${pageEvent.routerContext.newOutletId}-->`.length + `<outlet-wrapper id=\"${pageEvent.routerContext.newOutletId}\">`.length,\n      markup.lastIndexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) - `</outlet-wrapper>`.length\n    )}`;\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n  return markup;\n}\n",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1702914706706,
      "end": 1702914706706,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import.meta.env = {\"BASE_URL\":\"/\",\"MODE\":\"development\",\"DEV\":true,\"PROD\":false,\"SSR\":true};import.meta.env.START_SSR = true;import.meta.env.START_ISLANDS = false;import.meta.env.START_ENTRY_CLIENT = \"/home/yongqi/Repositories/yonggqiii.github.io/src/entry-client.tsx\";import.meta.env.START_ENTRY_SERVER = \"/home/yongqi/Repositories/yonggqiii.github.io/src/entry-server.tsx\";import.meta.env.START_INDEX_HTML = false;import.meta.env.START_ISLANDS_ROUTER = false;import.meta.env.START_ADAPTER = \"static\";import { renderToStream, renderToString, renderToStringAsync } from \"solid-js/web\";\nimport { internalFetch } from \"/node_modules/solid-start/api/internalFetch.ts\";\nimport { apiRoutes } from \"/node_modules/solid-start/api/middleware.ts\";\nimport { inlineServerFunctions } from \"/node_modules/solid-start/server/middleware.ts\";\nimport { redirect } from \"/node_modules/solid-start/server/responses.ts\";\nimport { FETCH_EVENT } from \"/node_modules/solid-start/server/types.tsx\";\nexport function renderSync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          return await event.env.getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = renderToString(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderAsync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = await renderToStringAsync(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderStream(fn, baseOptions = {}) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        if (false && event.request.headers.get(\"x-solid-referrer\")) {\n          let markup = await renderToStringAsync(() => fn(pageEvent), baseOptions);\n          if (pageEvent.routerContext && pageEvent.routerContext.url) {\n            return redirect(pageEvent.routerContext.url, {\n              headers: pageEvent.responseHeaders\n            });\n          }\n          markup = handleIslandsRouting(pageEvent, markup);\n          return new Response(markup, {\n            status: pageEvent.getStatusCode(),\n            headers: pageEvent.responseHeaders\n          });\n        }\n        const options = { ...baseOptions };\n        if (options.onCompleteAll) {\n          const og = options.onCompleteAll;\n          options.onCompleteAll = (options2) => {\n            handleStreamingRedirect(pageEvent)(options2);\n            og(options2);\n          };\n        } else\n          options.onCompleteAll = handleStreamingRedirect(pageEvent);\n        const { readable, writable } = new TransformStream();\n        const stream = renderToStream(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        handleStreamingIslandsRouting(pageEvent, writable);\n        stream.pipeTo(writable);\n        return new Response(readable, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nfunction handleStreamingIslandsRouting(pageEvent, writable) {\n  if (pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    writer.write(\n      encoder.encode(\n        `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=`\n      )\n    );\n    writer.releaseLock();\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n}\nfunction handleStreamingRedirect(context) {\n  return ({ write }) => {\n    if (context.routerContext && context.routerContext.url)\n      write(`<script>window.location=\"${context.routerContext.url}\"<\\/script>`);\n  };\n}\nfunction createPageEvent(event) {\n  let responseHeaders = new Headers({\n    \"Content-Type\": \"text/html\"\n  });\n  const prevPath = event.request.headers.get(\"x-solid-referrer\");\n  let statusCode = 200;\n  function setStatusCode(code) {\n    statusCode = code;\n  }\n  function getStatusCode() {\n    return statusCode;\n  }\n  const pageEvent = Object.freeze({\n    request: event.request,\n    prevUrl: prevPath || \"\",\n    routerContext: {},\n    tags: [],\n    env: event.env,\n    clientAddress: event.clientAddress,\n    locals: event.locals,\n    $type: FETCH_EVENT,\n    responseHeaders,\n    setStatusCode,\n    getStatusCode,\n    fetch: internalFetch\n  });\n  return pageEvent;\n}\nfunction handleIslandsRouting(pageEvent, markup) {\n  if (false && pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    markup = `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=${markup.slice(\n      markup.indexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) + `<!--${pageEvent.routerContext.newOutletId}-->`.length + `<outlet-wrapper id=\"${pageEvent.routerContext.newOutletId}\">`.length,\n      markup.lastIndexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) - `</outlet-wrapper>`.length\n    )}`;\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n  return markup;\n}\n",
      "start": 1702914706706,
      "end": 1702914706708,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
