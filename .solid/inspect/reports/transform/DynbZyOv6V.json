{
  "resolvedId": "/home/yongqi/Repositories/yonggqiii.github.io/node_modules/solid-start/data/Form.tsx?v=b59f1b3e",
  "transforms": [
    {
      "name": "__load__",
      "result": "/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { ComponentProps, createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\n\nexport interface FormAction<Data> {\n  action: string;\n  method: string;\n  formData: Data;\n  encType: string;\n}\n\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\n\ntype FormEncType = \"application/x-www-form-urlencoded\" | \"multipart/form-data\";\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\nexport interface SubmitFunction {\n  (\n    /**\n     * Specifies the `<form>` to be submitted to the server, a specific\n     * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n     * arbitrary data to submit.\n     *\n     * Note: When using a `<button>` its `name` and `value` will also be\n     * included in the form data that is submitted.\n     */\n    target:\n      | HTMLFormElement\n      | HTMLButtonElement\n      | HTMLInputElement\n      | FormData\n      | URLSearchParams\n      | { [name: string]: string }\n      | null,\n\n    /**\n     * Options that override the `<form>`'s own attributes. Required when\n     * submitting arbitrary data without a backing `<form>`.\n     */\n    options?: SubmitOptions\n  ): void;\n}\n\nexport type FormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n\nexport interface FormProps extends Omit<ComponentProps<\"form\">, \"method\" | \"onSubmit\"> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   *\n   * Note: If JavaScript is disabled, you'll need to implement your own \"method\n   * override\" to support more than just GET and POST.\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Normal `<form encType>`.\n   *\n   * Note: Remix only supports `application/x-www-form-urlencoded` right now\n   * but will soon support `multipart/form-data` as well.\n   */\n  // encType?: FormEncType;\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n\n  onSubmit?: (event: SubmitEvent) => void;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not be called.\n   */\n  onSubmission?: (submission: FormAction<FormData>) => void;\n}\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\ninterface FormImplProps extends FormProps {\n  onSubmmsion?: (submission: FormAction<FormData>) => void;\n}\n\nexport let FormImpl = (_props: FormImplProps) => {\n  let [props, rest] = splitProps(\n    mergeProps(\n      {\n        reloadDocument: false,\n        replace: false,\n        method: \"post\" as FormMethod,\n        action: \"/\",\n        encType: \"application/x-www-form-urlencoded\" as FormEncType\n      },\n      _props\n    ),\n    [\n      \"reloadDocument\",\n      \"replace\",\n      \"method\",\n      \"action\",\n      \"encType\",\n      \"onSubmission\",\n      \"onSubmit\",\n      \"children\",\n      \"ref\"\n    ]\n  );\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod: FormMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef: HTMLButtonElement | HTMLInputElement | null = null;\n  let form: HTMLFormElement | null = null;\n\n  createEffect(() => {\n    if (!form) return;\n\n    function handleClick(event: MouseEvent) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;\n      let submitButton = event.target.closest<HTMLButtonElement | HTMLInputElement>(\n        \"button,input[type=submit]\"\n      );\n\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return (\n    <form\n      ref={f => {\n        form = f;\n        if (typeof props.ref === \"function\") props.ref(f);\n      }}\n      method={formMethod}\n      action={_props.action}\n      enctype={props.encType}\n      // encType={encType}\n      onSubmit={\n        props.reloadDocument\n          ? undefined\n          : event => {\n              props.onSubmit && props.onSubmit(event);\n              if (event.defaultPrevented) return;\n              event.preventDefault();\n              submit(clickedButtonRef || event.currentTarget, {\n                method: props.method,\n                replace: props.replace\n              });\n              clickedButtonRef = null;\n            }\n      }\n      {...rest}\n    >\n      {props.children}\n    </form>\n  );\n};\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  // encType?: FormEncType;\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n\nexport function useSubmitImpl(\n  onSubmission: (sub: FormAction<FormData>) => void\n): SubmitFunction {\n  return (target, options = {}) => {\n    let method: string;\n    let action: string;\n    let encType: string;\n    let formData: FormData;\n\n    if (isFormElement(target)) {\n      let submissionTrigger: HTMLButtonElement | HTMLInputElement = (options as any)\n        .submissionTrigger;\n\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (\n      isButtonElement(target) ||\n      (isInputElement(target) && (target.type === \"submit\" || target.type === \"image\"))\n    ) {\n      let form = target.form;\n\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(\n          `Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`\n        );\n      }\n\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n\n    let { protocol, host } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n\n    let submission: FormAction<FormData> = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n",
      "start": 1720885728977,
      "end": 1720885728977
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1720885728977,
      "end": 1720885728977,
      "order": "pre"
    },
    {
      "name": "solid",
      "result": "import { template as _$template } from \"solid-js/web\";\nimport { getNextElement as _$getNextElement } from \"solid-js/web\";\nimport { runHydrationEvents as _$runHydrationEvents } from \"solid-js/web\";\nimport { insert as _$insert } from \"solid-js/web\";\nimport { setAttribute as _$setAttribute } from \"solid-js/web\";\nimport { use as _$use } from \"solid-js/web\";\nimport { spread as _$spread } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { memo as _$memo } from \"solid-js/web\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<form>`);\n/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\n\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\nexport let FormImpl = _props => {\n  let [props, rest] = splitProps(mergeProps({\n    reloadDocument: false,\n    replace: false,\n    method: \"post\",\n    action: \"/\",\n    encType: \"application/x-www-form-urlencoded\"\n  }, _props), [\"reloadDocument\", \"replace\", \"method\", \"action\", \"encType\", \"onSubmission\", \"onSubmit\", \"children\", \"ref\"]);\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef = null;\n  let form = null;\n  createEffect(() => {\n    if (!form) return;\n    function handleClick(event) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;\n      let submitButton = event.target.closest(\"button,input[type=submit]\");\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return (() => {\n    const _el$ = _$getNextElement(_tmpl$);\n    _$use(f => {\n      form = f;\n      if (typeof props.ref === \"function\") props.ref(f);\n    }, _el$);\n    _$setAttribute(_el$, \"method\", formMethod);\n    _$spread(_el$, _$mergeProps({\n      get action() {\n        return _props.action;\n      },\n      get enctype() {\n        return props.encType;\n      },\n      get onSubmit() {\n        return props.reloadDocument ? undefined : event => {\n          props.onSubmit && props.onSubmit(event);\n          if (event.defaultPrevented) return;\n          event.preventDefault();\n          submit(clickedButtonRef || event.currentTarget, {\n            method: props.method,\n            replace: props.replace\n          });\n          clickedButtonRef = null;\n        };\n      }\n    }, rest), false, true);\n    _$insert(_el$, () => props.children);\n    _$runHydrationEvents();\n    return _el$;\n  })();\n};\nexport function useSubmitImpl(onSubmission) {\n  return (target, options = {}) => {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    if (isFormElement(target)) {\n      let submissionTrigger = options.submissionTrigger;\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`);\n      }\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n    let {\n      protocol,\n      host\n    } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n    let submission = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}",
      "start": 1720885728977,
      "end": 1720885728984,
      "order": "pre",
      "sourcemaps": {
        "version": 3,
        "names": [
          "createEffect",
          "mergeProps",
          "onCleanup",
          "splitProps",
          "FormError",
          "FormImpl",
          "Form",
          "_props",
          "props",
          "rest",
          "reloadDocument",
          "replace",
          "method",
          "action",
          "encType",
          "submit",
          "useSubmitImpl",
          "submission",
          "onSubmission",
          "formMethod",
          "toLowerCase",
          "clickedButtonRef",
          "form",
          "handleClick",
          "event",
          "target",
          "HTMLElement",
          "SVGElement",
          "submitButton",
          "closest",
          "type",
          "addEventListener",
          "removeEventListener",
          "_el$",
          "_$getNextElement",
          "_tmpl$",
          "_$use",
          "f",
          "ref",
          "_$setAttribute",
          "_$spread",
          "_$mergeProps",
          "enctype",
          "onSubmit",
          "undefined",
          "defaultPrevented",
          "preventDefault",
          "currentTarget",
          "_$insert",
          "children",
          "_$runHydrationEvents",
          "options",
          "formData",
          "isFormElement",
          "submissionTrigger",
          "FormData",
          "name",
          "append",
          "value",
          "isButtonElement",
          "isInputElement",
          "Error",
          "getAttribute",
          "set",
          "isHtmlElement",
          "URLSearchParams",
          "Object",
          "keys",
          "protocol",
          "host",
          "window",
          "location",
          "url",
          "URL",
          "searchParams",
          "pathname",
          "search",
          "toUpperCase",
          "object",
          "tagName"
        ],
        "sources": [
          "Form.tsx"
        ],
        "sourcesContent": [
          "/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { ComponentProps, createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\n\nexport interface FormAction<Data> {\n  action: string;\n  method: string;\n  formData: Data;\n  encType: string;\n}\n\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\n\ntype FormEncType = \"application/x-www-form-urlencoded\" | \"multipart/form-data\";\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\nexport interface SubmitFunction {\n  (\n    /**\n     * Specifies the `<form>` to be submitted to the server, a specific\n     * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n     * arbitrary data to submit.\n     *\n     * Note: When using a `<button>` its `name` and `value` will also be\n     * included in the form data that is submitted.\n     */\n    target:\n      | HTMLFormElement\n      | HTMLButtonElement\n      | HTMLInputElement\n      | FormData\n      | URLSearchParams\n      | { [name: string]: string }\n      | null,\n\n    /**\n     * Options that override the `<form>`'s own attributes. Required when\n     * submitting arbitrary data without a backing `<form>`.\n     */\n    options?: SubmitOptions\n  ): void;\n}\n\nexport type FormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n\nexport interface FormProps extends Omit<ComponentProps<\"form\">, \"method\" | \"onSubmit\"> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   *\n   * Note: If JavaScript is disabled, you'll need to implement your own \"method\n   * override\" to support more than just GET and POST.\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Normal `<form encType>`.\n   *\n   * Note: Remix only supports `application/x-www-form-urlencoded` right now\n   * but will soon support `multipart/form-data` as well.\n   */\n  // encType?: FormEncType;\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n\n  onSubmit?: (event: SubmitEvent) => void;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not be called.\n   */\n  onSubmission?: (submission: FormAction<FormData>) => void;\n}\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\ninterface FormImplProps extends FormProps {\n  onSubmmsion?: (submission: FormAction<FormData>) => void;\n}\n\nexport let FormImpl = (_props: FormImplProps) => {\n  let [props, rest] = splitProps(\n    mergeProps(\n      {\n        reloadDocument: false,\n        replace: false,\n        method: \"post\" as FormMethod,\n        action: \"/\",\n        encType: \"application/x-www-form-urlencoded\" as FormEncType\n      },\n      _props\n    ),\n    [\n      \"reloadDocument\",\n      \"replace\",\n      \"method\",\n      \"action\",\n      \"encType\",\n      \"onSubmission\",\n      \"onSubmit\",\n      \"children\",\n      \"ref\"\n    ]\n  );\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod: FormMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef: HTMLButtonElement | HTMLInputElement | null = null;\n  let form: HTMLFormElement | null = null;\n\n  createEffect(() => {\n    if (!form) return;\n\n    function handleClick(event: MouseEvent) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;\n      let submitButton = event.target.closest<HTMLButtonElement | HTMLInputElement>(\n        \"button,input[type=submit]\"\n      );\n\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return (\n    <form\n      ref={f => {\n        form = f;\n        if (typeof props.ref === \"function\") props.ref(f);\n      }}\n      method={formMethod}\n      action={_props.action}\n      enctype={props.encType}\n      // encType={encType}\n      onSubmit={\n        props.reloadDocument\n          ? undefined\n          : event => {\n              props.onSubmit && props.onSubmit(event);\n              if (event.defaultPrevented) return;\n              event.preventDefault();\n              submit(clickedButtonRef || event.currentTarget, {\n                method: props.method,\n                replace: props.replace\n              });\n              clickedButtonRef = null;\n            }\n      }\n      {...rest}\n    >\n      {props.children}\n    </form>\n  );\n};\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  // encType?: FormEncType;\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n\nexport function useSubmitImpl(\n  onSubmission: (sub: FormAction<FormData>) => void\n): SubmitFunction {\n  return (target, options = {}) => {\n    let method: string;\n    let action: string;\n    let encType: string;\n    let formData: FormData;\n\n    if (isFormElement(target)) {\n      let submissionTrigger: HTMLButtonElement | HTMLInputElement = (options as any)\n        .submissionTrigger;\n\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (\n      isButtonElement(target) ||\n      (isInputElement(target) && (target.type === \"submit\" || target.type === \"image\"))\n    ) {\n      let form = target.form;\n\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(\n          `Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`\n        );\n      }\n\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n\n    let { protocol, host } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n\n    let submission: FormAction<FormData> = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n"
        ],
        "mappings": "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",
        "x_google_ignoreList": [
          0
        ]
      }
    },
    {
      "name": "vite:css",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { template as _$template } from \"/node_modules/.vite/deps/solid-js_web.js?v=b59f1b3e\";\nimport { getNextElement as _$getNextElement } from \"/node_modules/.vite/deps/solid-js_web.js?v=b59f1b3e\";\nimport { runHydrationEvents as _$runHydrationEvents } from \"/node_modules/.vite/deps/solid-js_web.js?v=b59f1b3e\";\nimport { insert as _$insert } from \"/node_modules/.vite/deps/solid-js_web.js?v=b59f1b3e\";\nimport { setAttribute as _$setAttribute } from \"/node_modules/.vite/deps/solid-js_web.js?v=b59f1b3e\";\nimport { use as _$use } from \"/node_modules/.vite/deps/solid-js_web.js?v=b59f1b3e\";\nimport { spread as _$spread } from \"/node_modules/.vite/deps/solid-js_web.js?v=b59f1b3e\";\nimport { mergeProps as _$mergeProps } from \"/node_modules/.vite/deps/solid-js_web.js?v=b59f1b3e\";\nimport { memo as _$memo } from \"/node_modules/.vite/deps/solid-js_web.js?v=b59f1b3e\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<form>`);\n/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { createEffect, mergeProps, onCleanup, splitProps } from \"/node_modules/.vite/deps/solid-js.js?v=b59f1b3e\";\nexport { FormError } from \"/node_modules/solid-start/data/FormError.tsx?v=b59f1b3e\";\nexport { FormImpl as Form };\n\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\nexport let FormImpl = _props => {\n  let [props, rest] = splitProps(mergeProps({\n    reloadDocument: false,\n    replace: false,\n    method: \"post\",\n    action: \"/\",\n    encType: \"application/x-www-form-urlencoded\"\n  }, _props), [\"reloadDocument\", \"replace\", \"method\", \"action\", \"encType\", \"onSubmission\", \"onSubmit\", \"children\", \"ref\"]);\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef = null;\n  let form = null;\n  createEffect(() => {\n    if (!form) return;\n    function handleClick(event) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;\n      let submitButton = event.target.closest(\"button,input[type=submit]\");\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return (() => {\n    const _el$ = _$getNextElement(_tmpl$);\n    _$use(f => {\n      form = f;\n      if (typeof props.ref === \"function\") props.ref(f);\n    }, _el$);\n    _$setAttribute(_el$, \"method\", formMethod);\n    _$spread(_el$, _$mergeProps({\n      get action() {\n        return _props.action;\n      },\n      get enctype() {\n        return props.encType;\n      },\n      get onSubmit() {\n        return props.reloadDocument ? undefined : event => {\n          props.onSubmit && props.onSubmit(event);\n          if (event.defaultPrevented) return;\n          event.preventDefault();\n          submit(clickedButtonRef || event.currentTarget, {\n            method: props.method,\n            replace: props.replace\n          });\n          clickedButtonRef = null;\n        };\n      }\n    }, rest), false, true);\n    _$insert(_el$, () => props.children);\n    _$runHydrationEvents();\n    return _el$;\n  })();\n};\nexport function useSubmitImpl(onSubmission) {\n  return (target, options = {}) => {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    if (isFormElement(target)) {\n      let submissionTrigger = options.submissionTrigger;\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`);\n      }\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n    let {\n      protocol,\n      host\n    } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n    let submission = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}",
      "start": 1720885728984,
      "end": 1720885728984,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
