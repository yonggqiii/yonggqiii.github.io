{
  "resolvedId": "/home/yongqi/Repositories/yonggqiii.github.io/node_modules/solid-start/server/server-functions/browser.ts?v=2ea599d4",
  "transforms": [
    {
      "name": "__load__",
      "result": "import {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  redirect,\n  XSolidStartContentTypeHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"../responses\";\n\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport { CreateServerFunction, ServerFunction } from \"./types\";\n\nexport async function parseResponse(request: Request, response: Response) {\n  const contentType =\n    response.headers.get(XSolidStartContentTypeHeader) ||\n    response.headers.get(ContentTypeHeader) ||\n    \"\";\n  if (contentType.includes(\"json\")) {\n    return await response.json();\n  } else if (contentType.includes(\"text\")) {\n    return await response.text();\n  } else if (contentType.includes(\"server-error\")) {\n    const data = await response.json();\n    return new ServerError(data.error.message, {\n      stack: data.error.stack,\n      status: response.status\n    });\n  } else if (contentType.includes(\"form-error\")) {\n    const data = await response.json();\n    return new FormError(data.error.message, {\n      fieldErrors: data.error.fieldErrors,\n      fields: data.error.fields,\n      stack: data.error.stack\n    });\n  } else if (contentType.includes(\"error\")) {\n    const data = await response.json();\n    const error = new Error(data.error.message);\n    if (data.error.stack) {\n      error.stack = data.error.stack;\n    }\n    return error;\n  } else if (contentType.includes(\"response\")) {\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader)!);\n    }\n    return response;\n  } else {\n    if (response.status === 200) {\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch {}\n    }\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader)!);\n    }\n    return response;\n  }\n}\n\nexport const server$ = ((_fn: any) => {\n  throw new Error(\"Should be compiled away\");\n}) as unknown as CreateServerFunction;\n\nfunction createRequestInit(...args: any[]): RequestInit {\n  // parsing args when a request is made from the browser for a server module\n  // FormData\n  // Request\n  // Headers\n  //\n  let body,\n    headers: Record<string, string> = {\n      [XSolidStartOrigin]: \"client\"\n    };\n\n  if (args[0] instanceof FormData) {\n    body = args[0];\n  } else {\n    // special case for when server is used as fetcher for createResource\n    // we set {}.value to undefined. This keeps the createResource API intact as the type\n    // of this object is { value: T | undefined; refetching: boolean }\n    // So the user is expected to check value for undefined, and by setting it as undefined\n    // we can match user expectations that they dont have access to previous data on\n    // the server\n    if (Array.isArray(args) && args.length > 2) {\n      let secondArg = args[1];\n      if (typeof secondArg === \"object\" && \"value\" in secondArg && \"refetching\" in secondArg) {\n        secondArg.value = undefined;\n      }\n    }\n    body = JSON.stringify(args, (key, value) => {\n      if (value instanceof Headers) {\n        return {\n          $type: \"headers\",\n          values: [...value.entries()]\n        };\n      }\n      if (value instanceof Request) {\n        return {\n          $type: \"request\",\n          url: value.url,\n          method: value.method,\n          headers: value.headers\n        };\n      }\n      return value;\n    });\n    headers[ContentTypeHeader] = JSONResponseType;\n  }\n\n  return {\n    method: \"POST\",\n    body: body,\n    headers: new Headers({\n      ...headers\n    })\n  };\n}\n\ntype ServerCall = (route: string, init: RequestInit) => Promise<Response>;\n\nserver$.createFetcher = (route, serverResource) => {\n  let fetcher: any = function (this: Request, ...args: any[]) {\n    if (this instanceof Request) {\n    }\n    const requestInit = serverResource ? createRequestInit(args[0]) : createRequestInit(...args);\n    // request body: json, formData, or string\n    return (server$.call as ServerCall)(route, requestInit);\n  };\n\n  fetcher.url = route;\n  fetcher.fetch = (init: RequestInit) => (server$.call as ServerCall)(route, init);\n  // fetcher.action = async (...args: any[]) => {\n  //   const requestInit = createRequestInit(...args);\n  //   // request body: json, formData, or string\n  //   return server$.call(route, requestInit);\n  // };\n  return fetcher as ServerFunction<any, any>;\n};\n\nserver$.call = async function (route: string, init: RequestInit) {\n  const request = new Request(new URL(route, window.location.href).href, init);\n\n  const response = await fetch(request);\n\n  // // throws response, error, form error, json object, string\n  if (response.headers.get(XSolidStartResponseTypeHeader) === \"throw\") {\n    throw await parseResponse(request, response);\n  } else {\n    return await parseResponse(request, response);\n  }\n} as any;\n\n// used to fetch from an API route on the server or client, without falling into\n// fetch problems on the server\nserver$.fetch = async function (route: string | URL, init: RequestInit) {\n  if (route instanceof URL || route.startsWith(\"http\")) {\n    return await fetch(route, init);\n  }\n  const request = new Request(new URL(route, window.location.href).href, init);\n  return await fetch(request);\n};\n",
      "start": 1720884034204,
      "end": 1720884034204
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1720884034204,
      "end": 1720884034204,
      "order": "pre"
    },
    {
      "name": "solid",
      "start": 1720884034204,
      "end": 1720884034204,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1720884034204,
      "end": 1720884034204,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  redirect,\n  XSolidStartContentTypeHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"../responses\";\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nexport async function parseResponse(request, response) {\n  const contentType = response.headers.get(XSolidStartContentTypeHeader) || response.headers.get(ContentTypeHeader) || \"\";\n  if (contentType.includes(\"json\")) {\n    return await response.json();\n  } else if (contentType.includes(\"text\")) {\n    return await response.text();\n  } else if (contentType.includes(\"server-error\")) {\n    const data = await response.json();\n    return new ServerError(data.error.message, {\n      stack: data.error.stack,\n      status: response.status\n    });\n  } else if (contentType.includes(\"form-error\")) {\n    const data = await response.json();\n    return new FormError(data.error.message, {\n      fieldErrors: data.error.fieldErrors,\n      fields: data.error.fields,\n      stack: data.error.stack\n    });\n  } else if (contentType.includes(\"error\")) {\n    const data = await response.json();\n    const error = new Error(data.error.message);\n    if (data.error.stack) {\n      error.stack = data.error.stack;\n    }\n    return error;\n  } else if (contentType.includes(\"response\")) {\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader));\n    }\n    return response;\n  } else {\n    if (response.status === 200) {\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch {\n      }\n    }\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader));\n    }\n    return response;\n  }\n}\nexport const server$ = (_fn) => {\n  throw new Error(\"Should be compiled away\");\n};\nfunction createRequestInit(...args) {\n  let body, headers = {\n    [XSolidStartOrigin]: \"client\"\n  };\n  if (args[0] instanceof FormData) {\n    body = args[0];\n  } else {\n    if (Array.isArray(args) && args.length > 2) {\n      let secondArg = args[1];\n      if (typeof secondArg === \"object\" && \"value\" in secondArg && \"refetching\" in secondArg) {\n        secondArg.value = void 0;\n      }\n    }\n    body = JSON.stringify(args, (key, value) => {\n      if (value instanceof Headers) {\n        return {\n          $type: \"headers\",\n          values: [...value.entries()]\n        };\n      }\n      if (value instanceof Request) {\n        return {\n          $type: \"request\",\n          url: value.url,\n          method: value.method,\n          headers: value.headers\n        };\n      }\n      return value;\n    });\n    headers[ContentTypeHeader] = JSONResponseType;\n  }\n  return {\n    method: \"POST\",\n    body,\n    headers: new Headers({\n      ...headers\n    })\n  };\n}\nserver$.createFetcher = (route, serverResource) => {\n  let fetcher = function(...args) {\n    if (this instanceof Request) {\n    }\n    const requestInit = serverResource ? createRequestInit(args[0]) : createRequestInit(...args);\n    return server$.call(route, requestInit);\n  };\n  fetcher.url = route;\n  fetcher.fetch = (init) => server$.call(route, init);\n  return fetcher;\n};\nserver$.call = async function(route, init) {\n  const request = new Request(new URL(route, window.location.href).href, init);\n  const response = await fetch(request);\n  if (response.headers.get(XSolidStartResponseTypeHeader) === \"throw\") {\n    throw await parseResponse(request, response);\n  } else {\n    return await parseResponse(request, response);\n  }\n};\nserver$.fetch = async function(route, init) {\n  if (route instanceof URL || route.startsWith(\"http\")) {\n    return await fetch(route, init);\n  }\n  const request = new Request(new URL(route, window.location.href).href, init);\n  return await fetch(request);\n};\n",
      "start": 1720884034204,
      "end": 1720884034209,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "browser.ts?v=2ea599d4"
        ],
        "sourcesContent": [
          "import {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  redirect,\n  XSolidStartContentTypeHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"../responses\";\n\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport { CreateServerFunction, ServerFunction } from \"./types\";\n\nexport async function parseResponse(request: Request, response: Response) {\n  const contentType =\n    response.headers.get(XSolidStartContentTypeHeader) ||\n    response.headers.get(ContentTypeHeader) ||\n    \"\";\n  if (contentType.includes(\"json\")) {\n    return await response.json();\n  } else if (contentType.includes(\"text\")) {\n    return await response.text();\n  } else if (contentType.includes(\"server-error\")) {\n    const data = await response.json();\n    return new ServerError(data.error.message, {\n      stack: data.error.stack,\n      status: response.status\n    });\n  } else if (contentType.includes(\"form-error\")) {\n    const data = await response.json();\n    return new FormError(data.error.message, {\n      fieldErrors: data.error.fieldErrors,\n      fields: data.error.fields,\n      stack: data.error.stack\n    });\n  } else if (contentType.includes(\"error\")) {\n    const data = await response.json();\n    const error = new Error(data.error.message);\n    if (data.error.stack) {\n      error.stack = data.error.stack;\n    }\n    return error;\n  } else if (contentType.includes(\"response\")) {\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader)!);\n    }\n    return response;\n  } else {\n    if (response.status === 200) {\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch {}\n    }\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader)!);\n    }\n    return response;\n  }\n}\n\nexport const server$ = ((_fn: any) => {\n  throw new Error(\"Should be compiled away\");\n}) as unknown as CreateServerFunction;\n\nfunction createRequestInit(...args: any[]): RequestInit {\n  // parsing args when a request is made from the browser for a server module\n  // FormData\n  // Request\n  // Headers\n  //\n  let body,\n    headers: Record<string, string> = {\n      [XSolidStartOrigin]: \"client\"\n    };\n\n  if (args[0] instanceof FormData) {\n    body = args[0];\n  } else {\n    // special case for when server is used as fetcher for createResource\n    // we set {}.value to undefined. This keeps the createResource API intact as the type\n    // of this object is { value: T | undefined; refetching: boolean }\n    // So the user is expected to check value for undefined, and by setting it as undefined\n    // we can match user expectations that they dont have access to previous data on\n    // the server\n    if (Array.isArray(args) && args.length > 2) {\n      let secondArg = args[1];\n      if (typeof secondArg === \"object\" && \"value\" in secondArg && \"refetching\" in secondArg) {\n        secondArg.value = undefined;\n      }\n    }\n    body = JSON.stringify(args, (key, value) => {\n      if (value instanceof Headers) {\n        return {\n          $type: \"headers\",\n          values: [...value.entries()]\n        };\n      }\n      if (value instanceof Request) {\n        return {\n          $type: \"request\",\n          url: value.url,\n          method: value.method,\n          headers: value.headers\n        };\n      }\n      return value;\n    });\n    headers[ContentTypeHeader] = JSONResponseType;\n  }\n\n  return {\n    method: \"POST\",\n    body: body,\n    headers: new Headers({\n      ...headers\n    })\n  };\n}\n\ntype ServerCall = (route: string, init: RequestInit) => Promise<Response>;\n\nserver$.createFetcher = (route, serverResource) => {\n  let fetcher: any = function (this: Request, ...args: any[]) {\n    if (this instanceof Request) {\n    }\n    const requestInit = serverResource ? createRequestInit(args[0]) : createRequestInit(...args);\n    // request body: json, formData, or string\n    return (server$.call as ServerCall)(route, requestInit);\n  };\n\n  fetcher.url = route;\n  fetcher.fetch = (init: RequestInit) => (server$.call as ServerCall)(route, init);\n  // fetcher.action = async (...args: any[]) => {\n  //   const requestInit = createRequestInit(...args);\n  //   // request body: json, formData, or string\n  //   return server$.call(route, requestInit);\n  // };\n  return fetcher as ServerFunction<any, any>;\n};\n\nserver$.call = async function (route: string, init: RequestInit) {\n  const request = new Request(new URL(route, window.location.href).href, init);\n\n  const response = await fetch(request);\n\n  // // throws response, error, form error, json object, string\n  if (response.headers.get(XSolidStartResponseTypeHeader) === \"throw\") {\n    throw await parseResponse(request, response);\n  } else {\n    return await parseResponse(request, response);\n  }\n} as any;\n\n// used to fetch from an API route on the server or client, without falling into\n// fetch problems on the server\nserver$.fetch = async function (route: string | URL, init: RequestInit) {\n  if (route instanceof URL || route.startsWith(\"http\")) {\n    return await fetch(route, init);\n  }\n  const request = new Request(new URL(route, window.location.href).href, init);\n  return await fetch(request);\n};\n"
        ],
        "mappings": "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",
        "names": [],
        "x_google_ignoreList": [
          0
        ]
      }
    },
    {
      "name": "vite:json",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  redirect,\n  XSolidStartContentTypeHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"/node_modules/solid-start/server/responses.ts?v=2ea599d4\";\nimport { FormError } from \"/node_modules/solid-start/data/index.ts?v=2ea599d4\";\nimport { ServerError } from \"/node_modules/solid-start/data/FormError.tsx?v=2ea599d4\";\nexport async function parseResponse(request, response) {\n  const contentType = response.headers.get(XSolidStartContentTypeHeader) || response.headers.get(ContentTypeHeader) || \"\";\n  if (contentType.includes(\"json\")) {\n    return await response.json();\n  } else if (contentType.includes(\"text\")) {\n    return await response.text();\n  } else if (contentType.includes(\"server-error\")) {\n    const data = await response.json();\n    return new ServerError(data.error.message, {\n      stack: data.error.stack,\n      status: response.status\n    });\n  } else if (contentType.includes(\"form-error\")) {\n    const data = await response.json();\n    return new FormError(data.error.message, {\n      fieldErrors: data.error.fieldErrors,\n      fields: data.error.fields,\n      stack: data.error.stack\n    });\n  } else if (contentType.includes(\"error\")) {\n    const data = await response.json();\n    const error = new Error(data.error.message);\n    if (data.error.stack) {\n      error.stack = data.error.stack;\n    }\n    return error;\n  } else if (contentType.includes(\"response\")) {\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader));\n    }\n    return response;\n  } else {\n    if (response.status === 200) {\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch {\n      }\n    }\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader));\n    }\n    return response;\n  }\n}\nexport const server$ = (_fn) => {\n  throw new Error(\"Should be compiled away\");\n};\nfunction createRequestInit(...args) {\n  let body, headers = {\n    [XSolidStartOrigin]: \"client\"\n  };\n  if (args[0] instanceof FormData) {\n    body = args[0];\n  } else {\n    if (Array.isArray(args) && args.length > 2) {\n      let secondArg = args[1];\n      if (typeof secondArg === \"object\" && \"value\" in secondArg && \"refetching\" in secondArg) {\n        secondArg.value = void 0;\n      }\n    }\n    body = JSON.stringify(args, (key, value) => {\n      if (value instanceof Headers) {\n        return {\n          $type: \"headers\",\n          values: [...value.entries()]\n        };\n      }\n      if (value instanceof Request) {\n        return {\n          $type: \"request\",\n          url: value.url,\n          method: value.method,\n          headers: value.headers\n        };\n      }\n      return value;\n    });\n    headers[ContentTypeHeader] = JSONResponseType;\n  }\n  return {\n    method: \"POST\",\n    body,\n    headers: new Headers({\n      ...headers\n    })\n  };\n}\nserver$.createFetcher = (route, serverResource) => {\n  let fetcher = function(...args) {\n    if (this instanceof Request) {\n    }\n    const requestInit = serverResource ? createRequestInit(args[0]) : createRequestInit(...args);\n    return server$.call(route, requestInit);\n  };\n  fetcher.url = route;\n  fetcher.fetch = (init) => server$.call(route, init);\n  return fetcher;\n};\nserver$.call = async function(route, init) {\n  const request = new Request(new URL(route, window.location.href).href, init);\n  const response = await fetch(request);\n  if (response.headers.get(XSolidStartResponseTypeHeader) === \"throw\") {\n    throw await parseResponse(request, response);\n  } else {\n    return await parseResponse(request, response);\n  }\n};\nserver$.fetch = async function(route, init) {\n  if (route instanceof URL || route.startsWith(\"http\")) {\n    return await fetch(route, init);\n  }\n  const request = new Request(new URL(route, window.location.href).href, init);\n  return await fetch(request);\n};\n",
      "start": 1720884034209,
      "end": 1720884034209,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
