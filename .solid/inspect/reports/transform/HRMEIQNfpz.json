{
  "resolvedId": "/home/yongqi/Repositories/yonggqiii.github.io/node_modules/solid-start/data/createRouteAction.tsx?v=f4e4b3e8",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { useNavigate, useSearchParams, type Navigator } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl, FormProps } from \"./Form\";\n\nimport type { ParentComponent } from \"solid-js\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { ServerFunctionEvent } from \"../server/types\";\nimport { refetchRouteData } from \"./createRouteData\";\n\ninterface ActionEvent extends ServerFunctionEvent {}\nexport interface Submission<T, U> {\n  input: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}\n\nexport type RouteAction<T, U> = [\n  {\n    pending: boolean;\n    input?: T;\n    result?: U;\n    error?: any;\n    clear: () => void;\n    retry: () => void;\n  },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\nexport type RouteMultiAction<T, U> = [\n  Submission<T, U>[] & { pending: Submission<T, U>[] },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\n\nexport type Invalidate = ((r: Response) => string | any[] | void) | string | any[];\n\nexport function createRouteAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [input, setInput] = createSignal<T | undefined>(init.input);\n  const [result, setResult] = createSignal<{ data?: U; error?: any } | undefined>(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables: T) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p\n      .then(async data => {\n        if (reqId === count) {\n          if (data instanceof Response) {\n            await handleResponse(data, navigate, options);\n          } else await handleRefetch(data as unknown as any[], options);\n          if (!data || isRedirectResponse(data)) setInput(undefined);\n          else setResult({ data });\n        }\n        return data;\n      })\n      .catch(async e => {\n        if (reqId === count) {\n          if (e instanceof Response) {\n            await handleResponse(e, navigate, options);\n          }\n          if (!isRedirectResponse(e)) {\n            setResult({ error: e });\n          } else setInput(undefined);\n        }\n        return undefined;\n      }) as Promise<U>;\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: Omit<FormProps, \"action\" | \"onSubmission\">) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    {\n      get pending() {\n        return !!input() && !result();\n      },\n      get input() {\n        return input();\n      },\n      get result() {\n        return result()?.data;\n      },\n      get error(): any {\n        return result()?.error;\n      },\n      clear() {\n        batch(() => {\n          setInput(undefined);\n          setResult(undefined);\n        });\n      },\n      retry() {\n        const variables = input();\n        if (!variables) throw new Error(\"No submission to retry\");\n        submit(variables);\n      }\n    },\n    submit\n  ];\n}\n\nexport function createRouteMultiAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteMultiAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [submissions, setSubmissions] = createSignal<Submission<T, U>[]>(\n    init.input ? [createSubmission(init.input)[0]] : []\n  );\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n\n  function createSubmission(variables: T) {\n    let submission: {\n      input: T,\n      readonly result: U | undefined,\n      readonly error: Error | undefined,\n      clear(): void,\n      retry(): void\n    };\n    const [result, setResult] = createSignal<{ data?: U; error?: any }>();\n    return [\n      (submission = {\n        input: variables,\n        get result() {\n          return result()?.data;\n        },\n        get error() {\n          return result()?.error;\n        },\n        clear() {\n          setSubmissions(v => v.filter(i => i.input !== variables));\n        },\n        retry() {\n          setResult(undefined);\n          return event && handleSubmit(fn(variables, event));\n        }\n      }),\n      handleSubmit\n    ] as const;\n    function handleSubmit(p: Promise<Response & { body: U } | U>): Promise<U> {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data as unknown as any[], options);\n        data ? setResult({ data }) : submission.clear();\n\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({ error: e });\n        } else submission.clear();\n      });\n      return p as Promise<U>;\n    }\n  }\n  function submit(variables: T) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: FormProps) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    new Proxy<Submission<T, U>[] & { pending: Submission<T, U>[] }>([] as any, {\n      get(_, property) {\n        if (property === $TRACK) return submissions();\n        if (property === \"pending\") return submissions().filter(sub => !sub.result);\n        return submissions()[property as keyof typeof submissions];\n      }\n    }),\n    submit\n  ];\n}\n\nfunction handleRefetch(response: Response | string | any[], options: { invalidate?: Invalidate } = {}) {\n  return refetchRouteData(\n    typeof options.invalidate === \"function\" ? options.invalidate(response as Response) : options.invalidate\n  );\n}\n\nfunction handleResponse(response: Response, navigate: Navigator, options?: { invalidate?: Invalidate }) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n\n  return handleRefetch(response, options);\n}\n\nfunction checkFlash<T>(fn: any) {\n  const [params] = useSearchParams();\n\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== (fn as any).url) {\n    return {};\n  }\n\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error\n        ? new FormError(param.error.message, {\n            fieldErrors: param.error.fieldErrors,\n            stack: param.error.stack,\n            form: param.error.form,\n            fields: param.error.fields\n          })\n        : undefined\n    },\n    input: input as unknown as T\n  };\n}\n",
      "start": 1720943932381,
      "end": 1720943932381
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1720943932381,
      "end": 1720943932381,
      "order": "pre"
    },
    {
      "name": "solid",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { useNavigate, useSearchParams } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl } from \"./Form\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { refetchRouteData } from \"./createRouteData\";\nexport function createRouteAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [input, setInput] = createSignal(init.input);\n  const [result, setResult] = createSignal(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p.then(async data => {\n      if (reqId === count) {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n        } else await handleRefetch(data, options);\n        if (!data || isRedirectResponse(data)) setInput(undefined);else setResult({\n          data\n        });\n      }\n      return data;\n    }).catch(async e => {\n      if (reqId === count) {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        }\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else setInput(undefined);\n      }\n      return undefined;\n    });\n  }\n  submit.url = fn.url;\n  submit.Form = props => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [{\n    get pending() {\n      return !!input() && !result();\n    },\n    get input() {\n      return input();\n    },\n    get result() {\n      return result()?.data;\n    },\n    get error() {\n      return result()?.error;\n    },\n    clear() {\n      batch(() => {\n        setInput(undefined);\n        setResult(undefined);\n      });\n    },\n    retry() {\n      const variables = input();\n      if (!variables) throw new Error(\"No submission to retry\");\n      submit(variables);\n    }\n  }, submit];\n}\nexport function createRouteMultiAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [submissions, setSubmissions] = createSignal(init.input ? [createSubmission(init.input)[0]] : []);\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n  function createSubmission(variables) {\n    let submission;\n    const [result, setResult] = createSignal();\n    return [submission = {\n      input: variables,\n      get result() {\n        return result()?.data;\n      },\n      get error() {\n        return result()?.error;\n      },\n      clear() {\n        setSubmissions(v => v.filter(i => i.input !== variables));\n      },\n      retry() {\n        setResult(undefined);\n        return event && handleSubmit(fn(variables, event));\n      }\n    }, handleSubmit];\n    function handleSubmit(p) {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data, options);\n        data ? setResult({\n          data\n        }) : submission.clear();\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else submission.clear();\n      });\n      return p;\n    }\n  }\n  function submit(variables) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = fn.url;\n  submit.Form = props => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [new Proxy([], {\n    get(_, property) {\n      if (property === $TRACK) return submissions();\n      if (property === \"pending\") return submissions().filter(sub => !sub.result);\n      return submissions()[property];\n    }\n  }), submit];\n}\nfunction handleRefetch(response, options = {}) {\n  return refetchRouteData(typeof options.invalidate === \"function\" ? options.invalidate(response) : options.invalidate);\n}\nfunction handleResponse(response, navigate, options) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n  return handleRefetch(response, options);\n}\nfunction checkFlash(fn) {\n  const [params] = useSearchParams();\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== fn.url) {\n    return {};\n  }\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error ? new FormError(param.error.message, {\n        fieldErrors: param.error.fieldErrors,\n        stack: param.error.stack,\n        form: param.error.form,\n        fields: param.error.fields\n      }) : undefined\n    },\n    input: input\n  };\n}",
      "start": 1720943932381,
      "end": 1720943932392,
      "order": "pre",
      "sourcemaps": {
        "version": 3,
        "names": [
          "useNavigate",
          "useSearchParams",
          "$TRACK",
          "batch",
          "createSignal",
          "useContext",
          "FormError",
          "FormImpl",
          "isRedirectResponse",
          "ServerContext",
          "useRequest",
          "refetchRouteData",
          "createRouteAction",
          "fn",
          "options",
          "init",
          "checkFlash",
          "input",
          "setInput",
          "result",
          "setResult",
          "navigate",
          "event",
          "count",
          "submit",
          "variables",
          "p",
          "reqId",
          "undefined",
          "then",
          "data",
          "Response",
          "handleResponse",
          "handleRefetch",
          "catch",
          "e",
          "error",
          "url",
          "Form",
          "props",
          "_$createComponent",
          "_$mergeProps",
          "action",
          "onSubmission",
          "submission",
          "formData",
          "children",
          "pending",
          "clear",
          "retry",
          "Error",
          "createRouteMultiAction",
          "submissions",
          "setSubmissions",
          "createSubmission",
          "v",
          "filter",
          "i",
          "handleSubmit",
          "body",
          "s",
          "Proxy",
          "get",
          "_",
          "property",
          "sub",
          "response",
          "invalidate",
          "locationUrl",
          "headers",
          "startsWith",
          "window",
          "location",
          "href",
          "params",
          "param",
          "form",
          "JSON",
          "parse",
          "Map",
          "entries",
          "message",
          "fieldErrors",
          "stack",
          "fields"
        ],
        "sources": [
          "createRouteAction.tsx"
        ],
        "sourcesContent": [
          "import { useNavigate, useSearchParams, type Navigator } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl, FormProps } from \"./Form\";\n\nimport type { ParentComponent } from \"solid-js\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { ServerFunctionEvent } from \"../server/types\";\nimport { refetchRouteData } from \"./createRouteData\";\n\ninterface ActionEvent extends ServerFunctionEvent {}\nexport interface Submission<T, U> {\n  input: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}\n\nexport type RouteAction<T, U> = [\n  {\n    pending: boolean;\n    input?: T;\n    result?: U;\n    error?: any;\n    clear: () => void;\n    retry: () => void;\n  },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\nexport type RouteMultiAction<T, U> = [\n  Submission<T, U>[] & { pending: Submission<T, U>[] },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\n\nexport type Invalidate = ((r: Response) => string | any[] | void) | string | any[];\n\nexport function createRouteAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [input, setInput] = createSignal<T | undefined>(init.input);\n  const [result, setResult] = createSignal<{ data?: U; error?: any } | undefined>(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables: T) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p\n      .then(async data => {\n        if (reqId === count) {\n          if (data instanceof Response) {\n            await handleResponse(data, navigate, options);\n          } else await handleRefetch(data as unknown as any[], options);\n          if (!data || isRedirectResponse(data)) setInput(undefined);\n          else setResult({ data });\n        }\n        return data;\n      })\n      .catch(async e => {\n        if (reqId === count) {\n          if (e instanceof Response) {\n            await handleResponse(e, navigate, options);\n          }\n          if (!isRedirectResponse(e)) {\n            setResult({ error: e });\n          } else setInput(undefined);\n        }\n        return undefined;\n      }) as Promise<U>;\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: Omit<FormProps, \"action\" | \"onSubmission\">) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    {\n      get pending() {\n        return !!input() && !result();\n      },\n      get input() {\n        return input();\n      },\n      get result() {\n        return result()?.data;\n      },\n      get error(): any {\n        return result()?.error;\n      },\n      clear() {\n        batch(() => {\n          setInput(undefined);\n          setResult(undefined);\n        });\n      },\n      retry() {\n        const variables = input();\n        if (!variables) throw new Error(\"No submission to retry\");\n        submit(variables);\n      }\n    },\n    submit\n  ];\n}\n\nexport function createRouteMultiAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteMultiAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [submissions, setSubmissions] = createSignal<Submission<T, U>[]>(\n    init.input ? [createSubmission(init.input)[0]] : []\n  );\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n\n  function createSubmission(variables: T) {\n    let submission: {\n      input: T,\n      readonly result: U | undefined,\n      readonly error: Error | undefined,\n      clear(): void,\n      retry(): void\n    };\n    const [result, setResult] = createSignal<{ data?: U; error?: any }>();\n    return [\n      (submission = {\n        input: variables,\n        get result() {\n          return result()?.data;\n        },\n        get error() {\n          return result()?.error;\n        },\n        clear() {\n          setSubmissions(v => v.filter(i => i.input !== variables));\n        },\n        retry() {\n          setResult(undefined);\n          return event && handleSubmit(fn(variables, event));\n        }\n      }),\n      handleSubmit\n    ] as const;\n    function handleSubmit(p: Promise<Response & { body: U } | U>): Promise<U> {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data as unknown as any[], options);\n        data ? setResult({ data }) : submission.clear();\n\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({ error: e });\n        } else submission.clear();\n      });\n      return p as Promise<U>;\n    }\n  }\n  function submit(variables: T) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: FormProps) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    new Proxy<Submission<T, U>[] & { pending: Submission<T, U>[] }>([] as any, {\n      get(_, property) {\n        if (property === $TRACK) return submissions();\n        if (property === \"pending\") return submissions().filter(sub => !sub.result);\n        return submissions()[property as keyof typeof submissions];\n      }\n    }),\n    submit\n  ];\n}\n\nfunction handleRefetch(response: Response | string | any[], options: { invalidate?: Invalidate } = {}) {\n  return refetchRouteData(\n    typeof options.invalidate === \"function\" ? options.invalidate(response as Response) : options.invalidate\n  );\n}\n\nfunction handleResponse(response: Response, navigate: Navigator, options?: { invalidate?: Invalidate }) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n\n  return handleRefetch(response, options);\n}\n\nfunction checkFlash<T>(fn: any) {\n  const [params] = useSearchParams();\n\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== (fn as any).url) {\n    return {};\n  }\n\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error\n        ? new FormError(param.error.message, {\n            fieldErrors: param.error.fieldErrors,\n            stack: param.error.stack,\n            form: param.error.form,\n            fields: param.error.fields\n          })\n        : undefined\n    },\n    input: input as unknown as T\n  };\n}\n"
        ],
        "mappings": "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",
        "x_google_ignoreList": [
          0
        ]
      }
    },
    {
      "name": "vite:css",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1720943932392,
      "end": 1720943932392,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { createComponent as _$createComponent } from \"/node_modules/.vite/deps/solid-js_web.js?v=f4e4b3e8\";\nimport { mergeProps as _$mergeProps } from \"/node_modules/.vite/deps/solid-js_web.js?v=f4e4b3e8\";\nimport { useNavigate, useSearchParams } from \"/node_modules/@solidjs/router/dist/index.jsx?v=f4e4b3e8\";\nimport { $TRACK, batch, createSignal, useContext } from \"/node_modules/.vite/deps/solid-js.js?v=f4e4b3e8\";\nimport { FormError, FormImpl } from \"/node_modules/solid-start/data/Form.tsx?v=f4e4b3e8\";\nimport { isRedirectResponse } from \"/node_modules/solid-start/server/responses.ts?v=f4e4b3e8\";\nimport { ServerContext, useRequest } from \"/node_modules/solid-start/server/ServerContext.tsx?v=f4e4b3e8\";\nimport { refetchRouteData } from \"/node_modules/solid-start/data/createRouteData.tsx?v=f4e4b3e8\";\nexport function createRouteAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [input, setInput] = createSignal(init.input);\n  const [result, setResult] = createSignal(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p.then(async data => {\n      if (reqId === count) {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n        } else await handleRefetch(data, options);\n        if (!data || isRedirectResponse(data)) setInput(undefined);else setResult({\n          data\n        });\n      }\n      return data;\n    }).catch(async e => {\n      if (reqId === count) {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        }\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else setInput(undefined);\n      }\n      return undefined;\n    });\n  }\n  submit.url = fn.url;\n  submit.Form = props => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [{\n    get pending() {\n      return !!input() && !result();\n    },\n    get input() {\n      return input();\n    },\n    get result() {\n      return result()?.data;\n    },\n    get error() {\n      return result()?.error;\n    },\n    clear() {\n      batch(() => {\n        setInput(undefined);\n        setResult(undefined);\n      });\n    },\n    retry() {\n      const variables = input();\n      if (!variables) throw new Error(\"No submission to retry\");\n      submit(variables);\n    }\n  }, submit];\n}\nexport function createRouteMultiAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [submissions, setSubmissions] = createSignal(init.input ? [createSubmission(init.input)[0]] : []);\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n  function createSubmission(variables) {\n    let submission;\n    const [result, setResult] = createSignal();\n    return [submission = {\n      input: variables,\n      get result() {\n        return result()?.data;\n      },\n      get error() {\n        return result()?.error;\n      },\n      clear() {\n        setSubmissions(v => v.filter(i => i.input !== variables));\n      },\n      retry() {\n        setResult(undefined);\n        return event && handleSubmit(fn(variables, event));\n      }\n    }, handleSubmit];\n    function handleSubmit(p) {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data, options);\n        data ? setResult({\n          data\n        }) : submission.clear();\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else submission.clear();\n      });\n      return p;\n    }\n  }\n  function submit(variables) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = fn.url;\n  submit.Form = props => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [new Proxy([], {\n    get(_, property) {\n      if (property === $TRACK) return submissions();\n      if (property === \"pending\") return submissions().filter(sub => !sub.result);\n      return submissions()[property];\n    }\n  }), submit];\n}\nfunction handleRefetch(response, options = {}) {\n  return refetchRouteData(typeof options.invalidate === \"function\" ? options.invalidate(response) : options.invalidate);\n}\nfunction handleResponse(response, navigate, options) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n  return handleRefetch(response, options);\n}\nfunction checkFlash(fn) {\n  const [params] = useSearchParams();\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== fn.url) {\n    return {};\n  }\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error ? new FormError(param.error.message, {\n        fieldErrors: param.error.fieldErrors,\n        stack: param.error.stack,\n        form: param.error.form,\n        fields: param.error.fields\n      }) : undefined\n    },\n    input: input\n  };\n}",
      "start": 1720943932392,
      "end": 1720943932393,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
