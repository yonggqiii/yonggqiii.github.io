{
  "resolvedId": "/home/yongqi/Repositories/yonggqiii.github.io/src/routes/research.tsx",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { Title } from \"solid-start\";\nimport Card from \"../components/Card\";\nexport default function Teaching() {\n  return (\n    <main>\n      <Title>Research - Foo Yong Qi</Title>\n      <h1>Research</h1>\n      <Card header=\"Type-Safe Auto-Completion of Incomplete Polymorphic Programs\" header_color=\"yellow\" border=\"peach\">\n        <h3>Abstract</h3>\n        <p>\n        Incomplete programs are ubiquitous in both web repositories and evolving software projects.  The ability to perform auto-completion on these incomplete programs provides several benefits, including allowing static analysis tools to analyse incomplete programs and boosting developer productivity. However, earlier efforts to do so (1) are unable to work with incomplete programs containing parametrically polymorphic types and (2) may not respect the type safety of the incomplete program.\n</p><p>\nIn this paper we present an algorithm that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. As this algorithm does so in a type-safe manner, it can also find non-trivial type errors in incomplete programs. Finally, we present results from a prototype implementation of this algorithm, <span style=\"font-variant: small-caps\">JavaCIP</span>.\n        </p>\n        <a href=\"../papers/javacip/Type-Safe Auto-Completion of Incomplete Polymorphic Programs.pdf\">Submitted Author's Copy (Under Review) </a> | <a href=\"../papers/javacip/Poster.pdf\">Poster</a>\n      </Card>\n    </main>\n  );\n}\n",
      "start": 1698297490169,
      "end": 1698297490169,
      "sourcemaps": {
        "version": 3,
        "names": [
          "Title",
          "Card",
          "Teaching",
          "_el$",
          "_$getNextElement",
          "_tmpl$6",
          "_el$8",
          "firstChild",
          "_el$9",
          "_co$",
          "_$getNextMarker",
          "nextSibling",
          "_el$2",
          "_el$10",
          "_el$11",
          "_co$2",
          "_$insert",
          "_$createComponent",
          "children",
          "header",
          "header_color",
          "border",
          "_tmpl$",
          "_tmpl$2",
          "_tmpl$3",
          "_tmpl$4",
          "_tmpl$5"
        ],
        "sources": [
          "/home/yongqi/Repositories/yonggqiii.github.io/src/routes/research.tsx"
        ],
        "sourcesContent": [
          "import { Title } from \"solid-start\";\nimport Card from \"../components/Card\";\nexport default function Teaching() {\n  return (\n    <main>\n      <Title>Research - Foo Yong Qi</Title>\n      <h1>Research</h1>\n      <Card header=\"Type-Safe Auto-Completion of Incomplete Polymorphic Programs\" header_color=\"yellow\" border=\"peach\">\n        <h3>Abstract</h3>\n        <p>\n        Incomplete programs are ubiquitous in both web repositories and evolving software projects.  The ability to perform auto-completion on these incomplete programs provides several benefits, including allowing static analysis tools to analyse incomplete programs and boosting developer productivity. However, earlier efforts to do so (1) are unable to work with incomplete programs containing parametrically polymorphic types and (2) may not respect the type safety of the incomplete program.\n</p><p>\nIn this paper we present an algorithm that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. As this algorithm does so in a type-safe manner, it can also find non-trivial type errors in incomplete programs. Finally, we present results from a prototype implementation of this algorithm, <span style=\"font-variant: small-caps\">JavaCIP</span>.\n        </p>\n        <a href=\"../papers/javacip/Type-Safe Auto-Completion of Incomplete Polymorphic Programs.pdf\">Submitted Author's Copy (Under Review) </a> | <a href=\"../papers/javacip/Poster.pdf\">Poster</a>\n      </Card>\n    </main>\n  );\n}\n"
        ],
        "mappings": ";;;;;;;;;;;AAAA,SAASA,KAAK,QAAQ,aAAa;AACnC,OAAOC,IAAI,MAAM,oBAAoB;AACrC,eAAe,SAASC,QAAQA,CAAA,EAAG;EACjC;IAAA,MAAAC,IAAA,GAAAC,gBAAA,CAAAC,OAAA;MAAAC,KAAA,GAAAH,IAAA,CAAAI,UAAA;MAAA,CAAAC,KAAA,EAAAC,IAAA,IAAAC,eAAA,CAAAJ,KAAA,CAAAK,WAAA;MAAAC,KAAA,GAAAJ,KAAA,CAAAG,WAAA;MAAAE,MAAA,GAAAD,KAAA,CAAAD,WAAA;MAAA,CAAAG,MAAA,EAAAC,KAAA,IAAAL,eAAA,CAAAG,MAAA,CAAAF,WAAA;IAAAK,QAAA,CAAAb,IAAA,EAAAc,iBAAA,CAEKjB,KAAK;MAAAkB,QAAA;IAAA,IAAAV,KAAA,EAAAC,IAAA;IAAAO,QAAA,CAAAb,IAAA,EAAAc,iBAAA,CAELhB,IAAI;MAACkB,MAAM;MAAgEC,YAAY;MAAUC,MAAM;MAAA,IAAAH,SAAA;QAAA,QAAAd,gBAAA,CAAAkB,MAAA,GAAAlB,gBAAA,CAAAmB,OAAA,GAAAnB,gBAAA,CAAAoB,OAAA,GAAApB,gBAAA,CAAAqB,OAAA,UAAArB,gBAAA,CAAAsB,OAAA;MAAA;IAAA,IAAAZ,MAAA,EAAAC,KAAA;IAAA,OAAAZ,IAAA;EAAA;AAW9G"
      }
    },
    {
      "name": "solid-start-file-system-router",
      "result": "import { template as _$template } from \"solid-js/web\";\nimport { getNextMarker as _$getNextMarker } from \"solid-js/web\";\nimport { insert as _$insert } from \"solid-js/web\";\nimport { getNextElement as _$getNextElement } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<h3>Abstract`),\n  _tmpl$2 = /*#__PURE__*/_$template(`<p>Incomplete programs are ubiquitous in both web repositories and evolving software projects. The ability to perform auto-completion on these incomplete programs provides several benefits, including allowing static analysis tools to analyse incomplete programs and boosting developer productivity. However, earlier efforts to do so (1) are unable to work with incomplete programs containing parametrically polymorphic types and (2) may not respect the type safety of the incomplete program.`),\n  _tmpl$3 = /*#__PURE__*/_$template(`<p>In this paper we present an algorithm that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. As this algorithm does so in a type-safe manner, it can also find non-trivial type errors in incomplete programs. Finally, we present results from a prototype implementation of this algorithm, <span style=font-variant:small-caps>JavaCIP</span>.`),\n  _tmpl$4 = /*#__PURE__*/_$template(`<a href=\"../papers/javacip/Type-Safe Auto-Completion of Incomplete Polymorphic Programs.pdf\">Submitted Author's Copy (Under Review) `),\n  _tmpl$5 = /*#__PURE__*/_$template(`<a href=../papers/javacip/Poster.pdf>Poster`),\n  _tmpl$6 = /*#__PURE__*/_$template(`<main><!$><!/><h1>Research</h1><!$><!/>`);\nimport { Title } from \"solid-start\";\nimport Card from \"../components/Card\";\nexport default function Teaching() {\n  return (() => {\n    const _el$ = _$getNextElement(_tmpl$6),\n      _el$8 = _el$.firstChild,\n      [_el$9, _co$] = _$getNextMarker(_el$8.nextSibling),\n      _el$2 = _el$9.nextSibling,\n      _el$10 = _el$2.nextSibling,\n      [_el$11, _co$2] = _$getNextMarker(_el$10.nextSibling);\n    _$insert(_el$, _$createComponent(Title, {\n      children: \"Research - Foo Yong Qi\"\n    }), _el$9, _co$);\n    _$insert(_el$, _$createComponent(Card, {\n      header: \"Type-Safe Auto-Completion of Incomplete Polymorphic Programs\",\n      header_color: \"yellow\",\n      border: \"peach\",\n      get children() {\n        return [_$getNextElement(_tmpl$), _$getNextElement(_tmpl$2), _$getNextElement(_tmpl$3), _$getNextElement(_tmpl$4), \" | \", _$getNextElement(_tmpl$5)];\n      }\n    }), _el$11, _co$2);\n    return _el$;\n  })();\n}",
      "start": 1698297490169,
      "end": 1698297490212,
      "order": "pre",
      "sourcemaps": {
        "version": 3,
        "names": [
          "Title",
          "Card",
          "Teaching",
          "_el$",
          "_$getNextElement",
          "_tmpl$6",
          "_el$8",
          "firstChild",
          "_el$9",
          "_co$",
          "_$getNextMarker",
          "nextSibling",
          "_el$2",
          "_el$10",
          "_el$11",
          "_co$2",
          "_$insert",
          "_$createComponent",
          "children",
          "header",
          "header_color",
          "border",
          "_tmpl$",
          "_tmpl$2",
          "_tmpl$3",
          "_tmpl$4",
          "_tmpl$5"
        ],
        "sources": [
          "/home/yongqi/Repositories/yonggqiii.github.io/src/routes/research.tsx"
        ],
        "sourcesContent": [
          "import { Title } from \"solid-start\";\nimport Card from \"../components/Card\";\nexport default function Teaching() {\n  return (\n    <main>\n      <Title>Research - Foo Yong Qi</Title>\n      <h1>Research</h1>\n      <Card header=\"Type-Safe Auto-Completion of Incomplete Polymorphic Programs\" header_color=\"yellow\" border=\"peach\">\n        <h3>Abstract</h3>\n        <p>\n        Incomplete programs are ubiquitous in both web repositories and evolving software projects.  The ability to perform auto-completion on these incomplete programs provides several benefits, including allowing static analysis tools to analyse incomplete programs and boosting developer productivity. However, earlier efforts to do so (1) are unable to work with incomplete programs containing parametrically polymorphic types and (2) may not respect the type safety of the incomplete program.\n</p><p>\nIn this paper we present an algorithm that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. As this algorithm does so in a type-safe manner, it can also find non-trivial type errors in incomplete programs. Finally, we present results from a prototype implementation of this algorithm, <span style=\"font-variant: small-caps\">JavaCIP</span>.\n        </p>\n        <a href=\"../papers/javacip/Type-Safe Auto-Completion of Incomplete Polymorphic Programs.pdf\">Submitted Author's Copy (Under Review) </a> | <a href=\"../papers/javacip/Poster.pdf\">Poster</a>\n      </Card>\n    </main>\n  );\n}\n"
        ],
        "mappings": ";;;;;;;;;;;AAAA,SAASA,KAAK,QAAQ,aAAa;AACnC,OAAOC,IAAI,MAAM,oBAAoB;AACrC,eAAe,SAASC,QAAQA,CAAA,EAAG;EACjC;IAAA,MAAAC,IAAA,GAAAC,gBAAA,CAAAC,OAAA;MAAAC,KAAA,GAAAH,IAAA,CAAAI,UAAA;MAAA,CAAAC,KAAA,EAAAC,IAAA,IAAAC,eAAA,CAAAJ,KAAA,CAAAK,WAAA;MAAAC,KAAA,GAAAJ,KAAA,CAAAG,WAAA;MAAAE,MAAA,GAAAD,KAAA,CAAAD,WAAA;MAAA,CAAAG,MAAA,EAAAC,KAAA,IAAAL,eAAA,CAAAG,MAAA,CAAAF,WAAA;IAAAK,QAAA,CAAAb,IAAA,EAAAc,iBAAA,CAEKjB,KAAK;MAAAkB,QAAA;IAAA,IAAAV,KAAA,EAAAC,IAAA;IAAAO,QAAA,CAAAb,IAAA,EAAAc,iBAAA,CAELhB,IAAI;MAACkB,MAAM;MAAgEC,YAAY;MAAUC,MAAM;MAAA,IAAAH,SAAA;QAAA,QAAAd,gBAAA,CAAAkB,MAAA,GAAAlB,gBAAA,CAAAmB,OAAA,GAAAnB,gBAAA,CAAAoB,OAAA,GAAApB,gBAAA,CAAAqB,OAAA,UAAArB,gBAAA,CAAAsB,OAAA;MAAA;IAAA,IAAAZ,MAAA,EAAAC,KAAA;IAAA,OAAAZ,IAAA;EAAA;AAW9G"
      }
    },
    {
      "name": "solid",
      "result": "import { $$component as _$$component } from \"solid-refresh\";\nimport { $$refresh as _$$refresh } from \"solid-refresh\";\nimport { $$registry as _$$registry } from \"solid-refresh\";\nconst _REGISTRY = _$$registry();\nimport { template as _$template } from \"solid-js/web\";\nimport { getNextMarker as _$getNextMarker } from \"solid-js/web\";\nimport { insert as _$insert } from \"solid-js/web\";\nimport { getNextElement as _$getNextElement } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<h3>Abstract`),\n  _tmpl$2 = /*#__PURE__*/_$template(`<p>Incomplete programs are ubiquitous in both web repositories and evolving software projects. The ability to perform auto-completion on these incomplete programs provides several benefits, including allowing static analysis tools to analyse incomplete programs and boosting developer productivity. However, earlier efforts to do so (1) are unable to work with incomplete programs containing parametrically polymorphic types and (2) may not respect the type safety of the incomplete program.`),\n  _tmpl$3 = /*#__PURE__*/_$template(`<p>In this paper we present an algorithm that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. As this algorithm does so in a type-safe manner, it can also find non-trivial type errors in incomplete programs. Finally, we present results from a prototype implementation of this algorithm, <span style=font-variant:small-caps>JavaCIP</span>.`),\n  _tmpl$4 = /*#__PURE__*/_$template(`<a href=\"../papers/javacip/Type-Safe Auto-Completion of Incomplete Polymorphic Programs.pdf\">Submitted Author's Copy (Under Review) `),\n  _tmpl$5 = /*#__PURE__*/_$template(`<a href=../papers/javacip/Poster.pdf>Poster`),\n  _tmpl$6 = /*#__PURE__*/_$template(`<main><!$><!/><h1>Research</h1><!$><!/>`);\nimport { Title } from \"solid-start\";\nimport Card from \"../components/Card\";\nexport default _$$component(_REGISTRY, \"Teaching\", function Teaching() {\n  return (() => {\n    const _el$ = _$getNextElement(_tmpl$6),\n      _el$8 = _el$.firstChild,\n      [_el$9, _co$] = _$getNextMarker(_el$8.nextSibling),\n      _el$2 = _el$9.nextSibling,\n      _el$10 = _el$2.nextSibling,\n      [_el$11, _co$2] = _$getNextMarker(_el$10.nextSibling);\n    _$insert(_el$, _$createComponent(Title, {\n      children: \"Research - Foo Yong Qi\"\n    }), _el$9, _co$);\n    _$insert(_el$, _$createComponent(Card, {\n      header: \"Type-Safe Auto-Completion of Incomplete Polymorphic Programs\",\n      header_color: \"yellow\",\n      border: \"peach\",\n      get children() {\n        return [_$getNextElement(_tmpl$), _$getNextElement(_tmpl$2), _$getNextElement(_tmpl$3), _$getNextElement(_tmpl$4), \" | \", _$getNextElement(_tmpl$5)];\n      }\n    }), _el$11, _co$2);\n    return _el$;\n  })();\n}, {\n  location: \"src/routes/research.tsx:14:15\"\n});\nif (import.meta.hot) {\n  _$$refresh(\"vite\", import.meta.hot, _REGISTRY);\n  import.meta.hot.accept();\n}",
      "start": 1698297490212,
      "end": 1698297490231,
      "order": "pre",
      "sourcemaps": {
        "version": 3,
        "names": [
          "template",
          "_$template",
          "getNextMarker",
          "_$getNextMarker",
          "insert",
          "_$insert",
          "getNextElement",
          "_$getNextElement",
          "createComponent",
          "_$createComponent",
          "_tmpl$",
          "_tmpl$2",
          "_tmpl$3",
          "_tmpl$4",
          "_tmpl$5",
          "_tmpl$6",
          "Title",
          "Card",
          "_$$component",
          "_REGISTRY",
          "Teaching",
          "_el$",
          "_el$8",
          "firstChild",
          "_el$9",
          "_co$",
          "nextSibling",
          "_el$2",
          "_el$10",
          "_el$11",
          "_co$2",
          "children",
          "header",
          "header_color",
          "border",
          "location",
          "import",
          "meta",
          "hot",
          "_$$refresh",
          "accept"
        ],
        "sources": [
          "/home/yongqi/Repositories/yonggqiii.github.io/src/routes/research.tsx"
        ],
        "sourcesContent": [
          "import { template as _$template } from \"solid-js/web\";\nimport { getNextMarker as _$getNextMarker } from \"solid-js/web\";\nimport { insert as _$insert } from \"solid-js/web\";\nimport { getNextElement as _$getNextElement } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<h3>Abstract`),\n  _tmpl$2 = /*#__PURE__*/_$template(`<p>Incomplete programs are ubiquitous in both web repositories and evolving software projects. The ability to perform auto-completion on these incomplete programs provides several benefits, including allowing static analysis tools to analyse incomplete programs and boosting developer productivity. However, earlier efforts to do so (1) are unable to work with incomplete programs containing parametrically polymorphic types and (2) may not respect the type safety of the incomplete program.`),\n  _tmpl$3 = /*#__PURE__*/_$template(`<p>In this paper we present an algorithm that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. As this algorithm does so in a type-safe manner, it can also find non-trivial type errors in incomplete programs. Finally, we present results from a prototype implementation of this algorithm, <span style=font-variant:small-caps>JavaCIP</span>.`),\n  _tmpl$4 = /*#__PURE__*/_$template(`<a href=\"../papers/javacip/Type-Safe Auto-Completion of Incomplete Polymorphic Programs.pdf\">Submitted Author's Copy (Under Review) `),\n  _tmpl$5 = /*#__PURE__*/_$template(`<a href=../papers/javacip/Poster.pdf>Poster`),\n  _tmpl$6 = /*#__PURE__*/_$template(`<main><!$><!/><h1>Research</h1><!$><!/>`);\nimport { Title } from \"solid-start\";\nimport Card from \"../components/Card\";\nexport default function Teaching() {\n  return (() => {\n    const _el$ = _$getNextElement(_tmpl$6),\n      _el$8 = _el$.firstChild,\n      [_el$9, _co$] = _$getNextMarker(_el$8.nextSibling),\n      _el$2 = _el$9.nextSibling,\n      _el$10 = _el$2.nextSibling,\n      [_el$11, _co$2] = _$getNextMarker(_el$10.nextSibling);\n    _$insert(_el$, _$createComponent(Title, {\n      children: \"Research - Foo Yong Qi\"\n    }), _el$9, _co$);\n    _$insert(_el$, _$createComponent(Card, {\n      header: \"Type-Safe Auto-Completion of Incomplete Polymorphic Programs\",\n      header_color: \"yellow\",\n      border: \"peach\",\n      get children() {\n        return [_$getNextElement(_tmpl$), _$getNextElement(_tmpl$2), _$getNextElement(_tmpl$3), _$getNextElement(_tmpl$4), \" | \", _$getNextElement(_tmpl$5)];\n      }\n    }), _el$11, _co$2);\n    return _el$;\n  })();\n}"
        ],
        "mappings": ";;;;AAAA,SAASA,QAAQ,IAAIC,UAAU,QAAQ,cAAc;AACrD,SAASC,aAAa,IAAIC,eAAe,QAAQ,cAAc;AAC/D,SAASC,MAAM,IAAIC,QAAQ,QAAQ,cAAc;AACjD,SAASC,cAAc,IAAIC,gBAAgB,QAAQ,cAAc;AACjE,SAASC,eAAe,IAAIC,iBAAiB,QAAQ,cAAc;AACnE,MAAMC,MAAM,GAAG,aAAaT,UAAU,CAAE,cAAa,CAAC;EACpDU,OAAO,GAAG,aAAaV,UAAU,CAAE,6eAA4e,CAAC;EAChhBW,OAAO,GAAG,aAAaX,UAAU,CAAE,odAAmd,CAAC;EACvfY,OAAO,GAAG,aAAaZ,UAAU,CAAE,sIAAqI,CAAC;EACzKa,OAAO,GAAG,aAAab,UAAU,CAAE,6CAA4C,CAAC;EAChFc,OAAO,GAAG,aAAad,UAAU,CAAE,yCAAwC,CAAC;AAC9E,SAASe,KAAK,QAAQ,aAAa;AACnC,OAAOC,IAAI,MAAM,oBAAoB;AACrC,eAAAC,YAAA,CAAAC,SAAA,uBAAwBC,QAAQA,CAAA,EAAG;EACjC,OAAO,CAAC,MAAM;IACZ,MAAMC,IAAI,GAAGd,gBAAgB,CAACQ,OAAO,CAAC;MACpCO,KAAK,GAAGD,IAAI,CAACE,UAAU;MACvB,CAACC,KAAK,EAAEC,IAAI,CAAC,GAAGtB,eAAe,CAACmB,KAAK,CAACI,WAAW,CAAC;MAClDC,KAAK,GAAGH,KAAK,CAACE,WAAW;MACzBE,MAAM,GAAGD,KAAK,CAACD,WAAW;MAC1B,CAACG,MAAM,EAAEC,KAAK,CAAC,GAAG3B,eAAe,CAACyB,MAAM,CAACF,WAAW,CAAC;IACvDrB,QAAQ,CAACgB,IAAI,EAAEZ,iBAAiB,CAACO,KAAK,EAAE;MACtCe,QAAQ,EAAE;IACZ,CAAC,CAAC,EAAEP,KAAK,EAAEC,IAAI,CAAC;IAChBpB,QAAQ,CAACgB,IAAI,EAAEZ,iBAAiB,CAACQ,IAAI,EAAE;MACrCe,MAAM,EAAE,8DAA8D;MACtEC,YAAY,EAAE,QAAQ;MACtBC,MAAM,EAAE,OAAO;MACf,IAAIH,QAAQA,CAAA,EAAG;QACb,OAAO,CAACxB,gBAAgB,CAACG,MAAM,CAAC,EAAEH,gBAAgB,CAACI,OAAO,CAAC,EAAEJ,gBAAgB,CAACK,OAAO,CAAC,EAAEL,gBAAgB,CAACM,OAAO,CAAC,EAAE,KAAK,EAAEN,gBAAgB,CAACO,OAAO,CAAC,CAAC;MACtJ;IACF,CAAC,CAAC,EAAEe,MAAM,EAAEC,KAAK,CAAC;IAClB,OAAOT,IAAI;EACb,CAAC,EAAE,CAAC;AACN,CAAC;EAAAc,QAAA;AAAA;AAAA,IAAAC,MAAA,CAAAC,IAAA,CAAAC,GAAA;EAAAC,UAAA,SAAAH,MAAA,CAAAC,IAAA,CAAAC,GAAA,EAAAnB,SAAA;EAAAiB,MAAA,CAAAC,IAAA,CAAAC,GAAA,CAAAE,MAAA;AAAA"
      }
    },
    {
      "name": "vite:css",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1698297490231,
      "end": 1698297490231,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/routes/research.tsx\");import { $$component as _$$component } from \"/@solid-refresh\";\nimport { $$refresh as _$$refresh } from \"/@solid-refresh\";\nimport { $$registry as _$$registry } from \"/@solid-refresh\";\nconst _REGISTRY = _$$registry();\nimport { template as _$template } from \"/node_modules/.vite/deps/solid-js_web.js?v=086a2f5f\";\nimport { getNextMarker as _$getNextMarker } from \"/node_modules/.vite/deps/solid-js_web.js?v=086a2f5f\";\nimport { insert as _$insert } from \"/node_modules/.vite/deps/solid-js_web.js?v=086a2f5f\";\nimport { getNextElement as _$getNextElement } from \"/node_modules/.vite/deps/solid-js_web.js?v=086a2f5f\";\nimport { createComponent as _$createComponent } from \"/node_modules/.vite/deps/solid-js_web.js?v=086a2f5f\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<h3>Abstract`),\n  _tmpl$2 = /*#__PURE__*/_$template(`<p>Incomplete programs are ubiquitous in both web repositories and evolving software projects. The ability to perform auto-completion on these incomplete programs provides several benefits, including allowing static analysis tools to analyse incomplete programs and boosting developer productivity. However, earlier efforts to do so (1) are unable to work with incomplete programs containing parametrically polymorphic types and (2) may not respect the type safety of the incomplete program.`),\n  _tmpl$3 = /*#__PURE__*/_$template(`<p>In this paper we present an algorithm that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. As this algorithm does so in a type-safe manner, it can also find non-trivial type errors in incomplete programs. Finally, we present results from a prototype implementation of this algorithm, <span style=font-variant:small-caps>JavaCIP</span>.`),\n  _tmpl$4 = /*#__PURE__*/_$template(`<a href=\"../papers/javacip/Type-Safe Auto-Completion of Incomplete Polymorphic Programs.pdf\">Submitted Author's Copy (Under Review) `),\n  _tmpl$5 = /*#__PURE__*/_$template(`<a href=../papers/javacip/Poster.pdf>Poster`),\n  _tmpl$6 = /*#__PURE__*/_$template(`<main><!$><!/><h1>Research</h1><!$><!/>`);\nimport { Title } from \"/node_modules/solid-start/index.tsx?v=086a2f5f\";\nimport Card from \"/src/components/Card.tsx\";\nexport default _$$component(_REGISTRY, \"Teaching\", function Teaching() {\n  return (() => {\n    const _el$ = _$getNextElement(_tmpl$6),\n      _el$8 = _el$.firstChild,\n      [_el$9, _co$] = _$getNextMarker(_el$8.nextSibling),\n      _el$2 = _el$9.nextSibling,\n      _el$10 = _el$2.nextSibling,\n      [_el$11, _co$2] = _$getNextMarker(_el$10.nextSibling);\n    _$insert(_el$, _$createComponent(Title, {\n      children: \"Research - Foo Yong Qi\"\n    }), _el$9, _co$);\n    _$insert(_el$, _$createComponent(Card, {\n      header: \"Type-Safe Auto-Completion of Incomplete Polymorphic Programs\",\n      header_color: \"yellow\",\n      border: \"peach\",\n      get children() {\n        return [_$getNextElement(_tmpl$), _$getNextElement(_tmpl$2), _$getNextElement(_tmpl$3), _$getNextElement(_tmpl$4), \" | \", _$getNextElement(_tmpl$5)];\n      }\n    }), _el$11, _co$2);\n    return _el$;\n  })();\n}, {\n  location: \"src/routes/research.tsx:14:15\"\n});\nif (import.meta.hot) {\n  _$$refresh(\"vite\", import.meta.hot, _REGISTRY);\n  import.meta.hot.accept();\n}",
      "start": 1698297490231,
      "end": 1698297490234,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
