{
  "resolvedId": "/home/yongqi/Repositories/yonggqiii.github.io/node_modules/solid-start/server/responses.ts?v=086a2f5f",
  "transforms": [
    {
      "name": "__load__",
      "result": "export const XSolidStartStatusCodeHeader = \"x-solidstart-status-code\";\nexport const XSolidStartLocationHeader = \"x-solidstart-location\";\nexport const LocationHeader = \"Location\";\nexport const ContentTypeHeader = \"content-type\";\nexport const XSolidStartResponseTypeHeader = \"x-solidstart-response-type\";\nexport const XSolidStartContentTypeHeader = \"x-solidstart-content-type\";\nexport const XSolidStartOrigin = \"x-solidstart-origin\";\nexport const JSONResponseType = \"application/json\";\n\n/**\n * A JSON response. Converts `data` to JSON and sets the `Content-Type` header.\n */\nexport function json<Data>(data: Data, init: number | ResponseInit = {}): Response {\n  let responseInit: any = init;\n  if (typeof init === \"number\") {\n    responseInit = { status: init };\n  }\n\n  let headers = new Headers(responseInit.headers);\n\n  if (!headers.has(ContentTypeHeader)) {\n    headers.set(ContentTypeHeader, \"application/json; charset=utf-8\");\n  }\n\n  const response = new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers\n  });\n\n  return response;\n}\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport function redirect(url: string, init: number | ResponseInit = 302): Response {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  if (url === \"\") {\n    url = \"/\";\n  }\n\n  if (process.env.NODE_ENV === \"development\") {\n    if (url.startsWith(\".\")) {\n      throw new Error(\"Relative URLs are not allowed in redirect\");\n    }\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(LocationHeader, url);\n\n  const response = new Response(null, {\n    ...responseInit,\n    headers: headers\n  });\n\n  return response;\n}\n\nexport function eventStream(\n  request: Request,\n  init: (send: (event: string, data: any) => void) => () => void\n) {\n  let stream = new ReadableStream({\n    start(controller) {\n      let encoder = new TextEncoder();\n      let send = (event: string, data: any) => {\n        controller.enqueue(encoder.encode(\"event: \" + event + \"\\n\"));\n        controller.enqueue(encoder.encode(\"data: \" + data + \"\\n\" + \"\\n\"));\n      };\n      let cleanup = init(send);\n      let closed = false;\n      let close = () => {\n        if (closed) return;\n        cleanup();\n        closed = true;\n        request.signal.removeEventListener(\"abort\", close);\n        controller.close();\n      };\n      request.signal.addEventListener(\"abort\", close);\n      if (request.signal.aborted) {\n        close();\n        return;\n      }\n    }\n  });\n  return new Response(stream, {\n    headers: { \"Content-Type\": \"text/event-stream\" }\n  });\n}\n\nexport function isResponse(value: any): value is Response {\n  return (\n    value != null &&\n    typeof value.status === \"number\" &&\n    typeof value.statusText === \"string\" &&\n    typeof value.headers === \"object\" &&\n    typeof value.body !== \"undefined\"\n  );\n}\n\nconst redirectStatusCodes = new Set([204, 301, 302, 303, 307, 308]);\n\nexport function isRedirectResponse(response: Response | any): response is Response {\n  return response && response instanceof Response && redirectStatusCodes.has(response.status);\n}\n\nexport class ResponseError extends Error implements Response {\n  status: number;\n  headers: Headers;\n  name = \"ResponseError\";\n  ok: boolean;\n  statusText: string;\n  redirected: boolean;\n  url: string;\n  constructor(response: Response) {\n    let message = JSON.stringify({\n      $type: \"response\",\n      status: response.status,\n      message: response.statusText,\n      headers: [...response.headers.entries()]\n    });\n    super(message);\n    this.status = response.status;\n    this.headers = new Map([...response.headers.entries()]) as any as Headers;\n    this.url = response.url;\n    this.ok = response.ok;\n    this.statusText = response.statusText;\n    this.redirected = response.redirected;\n    this.bodyUsed = false;\n    this.type = response.type;\n    this.response = () => response;\n  }\n\n  response: () => Response;\n  type: ResponseType;\n  clone(): Response {\n    return this.response();\n  }\n  get body(): ReadableStream<Uint8Array> {\n    return this.response().body!;\n  }\n  bodyUsed: boolean;\n  async arrayBuffer(): Promise<ArrayBuffer> {\n    return await this.response().arrayBuffer();\n  }\n  async blob(): Promise<Blob> {\n    return await this.response().blob();\n  }\n  async formData(): Promise<FormData> {\n    return await this.response().formData();\n  }\n\n  async text() {\n    return await this.response().text();\n  }\n\n  async json() {\n    return await this.response().json();\n  }\n}\n",
      "start": 1702914707896,
      "end": 1702914707896
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1702914707896,
      "end": 1702914707896,
      "order": "pre"
    },
    {
      "name": "solid",
      "start": 1702914707896,
      "end": 1702914707896,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1702914707896,
      "end": 1702914707896,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "export const XSolidStartStatusCodeHeader = \"x-solidstart-status-code\";\nexport const XSolidStartLocationHeader = \"x-solidstart-location\";\nexport const LocationHeader = \"Location\";\nexport const ContentTypeHeader = \"content-type\";\nexport const XSolidStartResponseTypeHeader = \"x-solidstart-response-type\";\nexport const XSolidStartContentTypeHeader = \"x-solidstart-content-type\";\nexport const XSolidStartOrigin = \"x-solidstart-origin\";\nexport const JSONResponseType = \"application/json\";\nexport function json(data, init = {}) {\n  let responseInit = init;\n  if (typeof init === \"number\") {\n    responseInit = { status: init };\n  }\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(ContentTypeHeader)) {\n    headers.set(ContentTypeHeader, \"application/json; charset=utf-8\");\n  }\n  const response = new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers\n  });\n  return response;\n}\nexport function redirect(url, init = 302) {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  if (url === \"\") {\n    url = \"/\";\n  }\n  if (process.env.NODE_ENV === \"development\") {\n    if (url.startsWith(\".\")) {\n      throw new Error(\"Relative URLs are not allowed in redirect\");\n    }\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(LocationHeader, url);\n  const response = new Response(null, {\n    ...responseInit,\n    headers\n  });\n  return response;\n}\nexport function eventStream(request, init) {\n  let stream = new ReadableStream({\n    start(controller) {\n      let encoder = new TextEncoder();\n      let send = (event, data) => {\n        controller.enqueue(encoder.encode(\"event: \" + event + \"\\n\"));\n        controller.enqueue(encoder.encode(\"data: \" + data + \"\\n\\n\"));\n      };\n      let cleanup = init(send);\n      let closed = false;\n      let close = () => {\n        if (closed)\n          return;\n        cleanup();\n        closed = true;\n        request.signal.removeEventListener(\"abort\", close);\n        controller.close();\n      };\n      request.signal.addEventListener(\"abort\", close);\n      if (request.signal.aborted) {\n        close();\n        return;\n      }\n    }\n  });\n  return new Response(stream, {\n    headers: { \"Content-Type\": \"text/event-stream\" }\n  });\n}\nexport function isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nconst redirectStatusCodes = /* @__PURE__ */ new Set([204, 301, 302, 303, 307, 308]);\nexport function isRedirectResponse(response) {\n  return response && response instanceof Response && redirectStatusCodes.has(response.status);\n}\nexport class ResponseError extends Error {\n  status;\n  headers;\n  name = \"ResponseError\";\n  ok;\n  statusText;\n  redirected;\n  url;\n  constructor(response) {\n    let message = JSON.stringify({\n      $type: \"response\",\n      status: response.status,\n      message: response.statusText,\n      headers: [...response.headers.entries()]\n    });\n    super(message);\n    this.status = response.status;\n    this.headers = new Map([...response.headers.entries()]);\n    this.url = response.url;\n    this.ok = response.ok;\n    this.statusText = response.statusText;\n    this.redirected = response.redirected;\n    this.bodyUsed = false;\n    this.type = response.type;\n    this.response = () => response;\n  }\n  response;\n  type;\n  clone() {\n    return this.response();\n  }\n  get body() {\n    return this.response().body;\n  }\n  bodyUsed;\n  async arrayBuffer() {\n    return await this.response().arrayBuffer();\n  }\n  async blob() {\n    return await this.response().blob();\n  }\n  async formData() {\n    return await this.response().formData();\n  }\n  async text() {\n    return await this.response().text();\n  }\n  async json() {\n    return await this.response().json();\n  }\n}\n",
      "start": 1702914707896,
      "end": 1702914707900,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "responses.ts?v=086a2f5f"
        ],
        "sourcesContent": [
          "export const XSolidStartStatusCodeHeader = \"x-solidstart-status-code\";\nexport const XSolidStartLocationHeader = \"x-solidstart-location\";\nexport const LocationHeader = \"Location\";\nexport const ContentTypeHeader = \"content-type\";\nexport const XSolidStartResponseTypeHeader = \"x-solidstart-response-type\";\nexport const XSolidStartContentTypeHeader = \"x-solidstart-content-type\";\nexport const XSolidStartOrigin = \"x-solidstart-origin\";\nexport const JSONResponseType = \"application/json\";\n\n/**\n * A JSON response. Converts `data` to JSON and sets the `Content-Type` header.\n */\nexport function json<Data>(data: Data, init: number | ResponseInit = {}): Response {\n  let responseInit: any = init;\n  if (typeof init === \"number\") {\n    responseInit = { status: init };\n  }\n\n  let headers = new Headers(responseInit.headers);\n\n  if (!headers.has(ContentTypeHeader)) {\n    headers.set(ContentTypeHeader, \"application/json; charset=utf-8\");\n  }\n\n  const response = new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers\n  });\n\n  return response;\n}\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport function redirect(url: string, init: number | ResponseInit = 302): Response {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  if (url === \"\") {\n    url = \"/\";\n  }\n\n  if (process.env.NODE_ENV === \"development\") {\n    if (url.startsWith(\".\")) {\n      throw new Error(\"Relative URLs are not allowed in redirect\");\n    }\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(LocationHeader, url);\n\n  const response = new Response(null, {\n    ...responseInit,\n    headers: headers\n  });\n\n  return response;\n}\n\nexport function eventStream(\n  request: Request,\n  init: (send: (event: string, data: any) => void) => () => void\n) {\n  let stream = new ReadableStream({\n    start(controller) {\n      let encoder = new TextEncoder();\n      let send = (event: string, data: any) => {\n        controller.enqueue(encoder.encode(\"event: \" + event + \"\\n\"));\n        controller.enqueue(encoder.encode(\"data: \" + data + \"\\n\" + \"\\n\"));\n      };\n      let cleanup = init(send);\n      let closed = false;\n      let close = () => {\n        if (closed) return;\n        cleanup();\n        closed = true;\n        request.signal.removeEventListener(\"abort\", close);\n        controller.close();\n      };\n      request.signal.addEventListener(\"abort\", close);\n      if (request.signal.aborted) {\n        close();\n        return;\n      }\n    }\n  });\n  return new Response(stream, {\n    headers: { \"Content-Type\": \"text/event-stream\" }\n  });\n}\n\nexport function isResponse(value: any): value is Response {\n  return (\n    value != null &&\n    typeof value.status === \"number\" &&\n    typeof value.statusText === \"string\" &&\n    typeof value.headers === \"object\" &&\n    typeof value.body !== \"undefined\"\n  );\n}\n\nconst redirectStatusCodes = new Set([204, 301, 302, 303, 307, 308]);\n\nexport function isRedirectResponse(response: Response | any): response is Response {\n  return response && response instanceof Response && redirectStatusCodes.has(response.status);\n}\n\nexport class ResponseError extends Error implements Response {\n  status: number;\n  headers: Headers;\n  name = \"ResponseError\";\n  ok: boolean;\n  statusText: string;\n  redirected: boolean;\n  url: string;\n  constructor(response: Response) {\n    let message = JSON.stringify({\n      $type: \"response\",\n      status: response.status,\n      message: response.statusText,\n      headers: [...response.headers.entries()]\n    });\n    super(message);\n    this.status = response.status;\n    this.headers = new Map([...response.headers.entries()]) as any as Headers;\n    this.url = response.url;\n    this.ok = response.ok;\n    this.statusText = response.statusText;\n    this.redirected = response.redirected;\n    this.bodyUsed = false;\n    this.type = response.type;\n    this.response = () => response;\n  }\n\n  response: () => Response;\n  type: ResponseType;\n  clone(): Response {\n    return this.response();\n  }\n  get body(): ReadableStream<Uint8Array> {\n    return this.response().body!;\n  }\n  bodyUsed: boolean;\n  async arrayBuffer(): Promise<ArrayBuffer> {\n    return await this.response().arrayBuffer();\n  }\n  async blob(): Promise<Blob> {\n    return await this.response().blob();\n  }\n  async formData(): Promise<FormData> {\n    return await this.response().formData();\n  }\n\n  async text() {\n    return await this.response().text();\n  }\n\n  async json() {\n    return await this.response().json();\n  }\n}\n"
        ],
        "mappings": "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",
        "names": [],
        "x_google_ignoreList": [
          0
        ]
      }
    },
    {
      "name": "vite:json",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "result": "export const XSolidStartStatusCodeHeader = \"x-solidstart-status-code\";\nexport const XSolidStartLocationHeader = \"x-solidstart-location\";\nexport const LocationHeader = \"Location\";\nexport const ContentTypeHeader = \"content-type\";\nexport const XSolidStartResponseTypeHeader = \"x-solidstart-response-type\";\nexport const XSolidStartContentTypeHeader = \"x-solidstart-content-type\";\nexport const XSolidStartOrigin = \"x-solidstart-origin\";\nexport const JSONResponseType = \"application/json\";\nexport function json(data, init = {}) {\n  let responseInit = init;\n  if (typeof init === \"number\") {\n    responseInit = { status: init };\n  }\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(ContentTypeHeader)) {\n    headers.set(ContentTypeHeader, \"application/json; charset=utf-8\");\n  }\n  const response = new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers\n  });\n  return response;\n}\nexport function redirect(url, init = 302) {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  if (url === \"\") {\n    url = \"/\";\n  }\n  if (\"development\" === \"development\") {\n    if (url.startsWith(\".\")) {\n      throw new Error(\"Relative URLs are not allowed in redirect\");\n    }\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(LocationHeader, url);\n  const response = new Response(null, {\n    ...responseInit,\n    headers\n  });\n  return response;\n}\nexport function eventStream(request, init) {\n  let stream = new ReadableStream({\n    start(controller) {\n      let encoder = new TextEncoder();\n      let send = (event, data) => {\n        controller.enqueue(encoder.encode(\"event: \" + event + \"\\n\"));\n        controller.enqueue(encoder.encode(\"data: \" + data + \"\\n\\n\"));\n      };\n      let cleanup = init(send);\n      let closed = false;\n      let close = () => {\n        if (closed)\n          return;\n        cleanup();\n        closed = true;\n        request.signal.removeEventListener(\"abort\", close);\n        controller.close();\n      };\n      request.signal.addEventListener(\"abort\", close);\n      if (request.signal.aborted) {\n        close();\n        return;\n      }\n    }\n  });\n  return new Response(stream, {\n    headers: { \"Content-Type\": \"text/event-stream\" }\n  });\n}\nexport function isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nconst redirectStatusCodes = /* @__PURE__ */ new Set([204, 301, 302, 303, 307, 308]);\nexport function isRedirectResponse(response) {\n  return response && response instanceof Response && redirectStatusCodes.has(response.status);\n}\nexport class ResponseError extends Error {\n  status;\n  headers;\n  name = \"ResponseError\";\n  ok;\n  statusText;\n  redirected;\n  url;\n  constructor(response) {\n    let message = JSON.stringify({\n      $type: \"response\",\n      status: response.status,\n      message: response.statusText,\n      headers: [...response.headers.entries()]\n    });\n    super(message);\n    this.status = response.status;\n    this.headers = new Map([...response.headers.entries()]);\n    this.url = response.url;\n    this.ok = response.ok;\n    this.statusText = response.statusText;\n    this.redirected = response.redirected;\n    this.bodyUsed = false;\n    this.type = response.type;\n    this.response = () => response;\n  }\n  response;\n  type;\n  clone() {\n    return this.response();\n  }\n  get body() {\n    return this.response().body;\n  }\n  bodyUsed;\n  async arrayBuffer() {\n    return await this.response().arrayBuffer();\n  }\n  async blob() {\n    return await this.response().blob();\n  }\n  async formData() {\n    return await this.response().formData();\n  }\n  async text() {\n    return await this.response().text();\n  }\n  async json() {\n    return await this.response().json();\n  }\n}\n",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:import-analysis",
      "result": "export const XSolidStartStatusCodeHeader = \"x-solidstart-status-code\";\nexport const XSolidStartLocationHeader = \"x-solidstart-location\";\nexport const LocationHeader = \"Location\";\nexport const ContentTypeHeader = \"content-type\";\nexport const XSolidStartResponseTypeHeader = \"x-solidstart-response-type\";\nexport const XSolidStartContentTypeHeader = \"x-solidstart-content-type\";\nexport const XSolidStartOrigin = \"x-solidstart-origin\";\nexport const JSONResponseType = \"application/json\";\nexport function json(data, init = {}) {\n  let responseInit = init;\n  if (typeof init === \"number\") {\n    responseInit = { status: init };\n  }\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(ContentTypeHeader)) {\n    headers.set(ContentTypeHeader, \"application/json; charset=utf-8\");\n  }\n  const response = new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers\n  });\n  return response;\n}\nexport function redirect(url, init = 302) {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  if (url === \"\") {\n    url = \"/\";\n  }\n  if (\"development\" === \"development\") {\n    if (url.startsWith(\".\")) {\n      throw new Error(\"Relative URLs are not allowed in redirect\");\n    }\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(LocationHeader, url);\n  const response = new Response(null, {\n    ...responseInit,\n    headers\n  });\n  return response;\n}\nexport function eventStream(request, init) {\n  let stream = new ReadableStream({\n    start(controller) {\n      let encoder = new TextEncoder();\n      let send = (event, data) => {\n        controller.enqueue(encoder.encode(\"event: \" + event + \"\\n\"));\n        controller.enqueue(encoder.encode(\"data: \" + data + \"\\n\\n\"));\n      };\n      let cleanup = init(send);\n      let closed = false;\n      let close = () => {\n        if (closed)\n          return;\n        cleanup();\n        closed = true;\n        request.signal.removeEventListener(\"abort\", close);\n        controller.close();\n      };\n      request.signal.addEventListener(\"abort\", close);\n      if (request.signal.aborted) {\n        close();\n        return;\n      }\n    }\n  });\n  return new Response(stream, {\n    headers: { \"Content-Type\": \"text/event-stream\" }\n  });\n}\nexport function isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nconst redirectStatusCodes = /* @__PURE__ */ new Set([204, 301, 302, 303, 307, 308]);\nexport function isRedirectResponse(response) {\n  return response && response instanceof Response && redirectStatusCodes.has(response.status);\n}\nexport class ResponseError extends Error {\n  status;\n  headers;\n  name = \"ResponseError\";\n  ok;\n  statusText;\n  redirected;\n  url;\n  constructor(response) {\n    let message = JSON.stringify({\n      $type: \"response\",\n      status: response.status,\n      message: response.statusText,\n      headers: [...response.headers.entries()]\n    });\n    super(message);\n    this.status = response.status;\n    this.headers = new Map([...response.headers.entries()]);\n    this.url = response.url;\n    this.ok = response.ok;\n    this.statusText = response.statusText;\n    this.redirected = response.redirected;\n    this.bodyUsed = false;\n    this.type = response.type;\n    this.response = () => response;\n  }\n  response;\n  type;\n  clone() {\n    return this.response();\n  }\n  get body() {\n    return this.response().body;\n  }\n  bodyUsed;\n  async arrayBuffer() {\n    return await this.response().arrayBuffer();\n  }\n  async blob() {\n    return await this.response().blob();\n  }\n  async formData() {\n    return await this.response().formData();\n  }\n  async text() {\n    return await this.response().text();\n  }\n  async json() {\n    return await this.response().json();\n  }\n}\n",
      "start": 1702914707900,
      "end": 1702914707900,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
