<!DOCTYPE html><html lang="en" ><head ><meta data-sm="0-0-0-0-0-0-0-0-0-0-1-0" charset="utf-8"/><meta data-sm="0-0-0-0-0-0-0-0-0-0-2-0" name="viewport" content="width=device-width, initial-scale=1"/><title data-sm="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-1-0">Research - Foo Yong Qi</title><link rel="modulepreload" href="/assets/research-c3e7189c.js"><link rel="modulepreload" href="/assets/entry-client-503078e3.js"><link rel="stylesheet" href="/assets/entry-client-2ac6917b.css"><link rel="modulepreload" href="/assets/Card-9aaf02af.js"><link rel="stylesheet" href="/assets/Card-73b0cb51.css"></head><body ><!--!$e0-0-0-0-0-0-0-0-0-1-0-0-0-0-0--><nav data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0"><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-1-0" link="true" href="/" class="navitem active" aria-current="page">Home</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-2-0" link="true" href="/cv" class="navitem inactive" >CV</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-3-0" link="true" href="/teaching" class="navitem inactive" >Teaching</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-4-0" link="true" href="/research" class="navitem active" aria-current="page">Research</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-5-0" link="true" href="/fun" class="navitem inactive" >Fun</a><!--/--></nav><main data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-0"><!--$--><!--/--><h1>Research</h1><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-0" class="peach-border card"><h2 class="yellow">Type-Safe Auto-Completion of Incomplete Polymorphic Programs</h2><!--$--><h3 data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-1">Abstract</h3><p data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-2">Incomplete programs are ubiquitous in both web repositories and evolving software projects. The ability to perform auto-completion on these incomplete programs provides several benefits, including allowing static analysis tools to analyse incomplete programs and boosting developer productivity. However, earlier efforts to do so (1) are unable to work with incomplete programs containing parametrically polymorphic types and (2) may not respect the type safety of the incomplete program.</p><p data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-3">In this paper we present an algorithm that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. As this algorithm does so in a type-safe manner, it can also find non-trivial type errors in incomplete programs. Finally, we present results from a prototype implementation of this algorithm, <span style="font-variant:small-caps">JavaCIP</span>.</p><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-4" href="../papers/javacip/Type-Safe Auto-Completion of Incomplete Polymorphic Programs.pdf">Submitted Author's Copy (Under Review) </a> | <a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-5" href="../papers/javacip/Poster.pdf">Poster</a><!--/--></div><!--/--></main><!--!$/e0-0-0-0-0-0-0-0-0-1-0-0-0-0-0--><script>window._$HY||(e=>{let t=e=>e&&e.hasAttribute&&(e.hasAttribute("data-hk")?e:t(e.host&&e.host.nodeType?e.host:e.parentNode));["click", "input"].forEach((o=>document.addEventListener(o,(o=>{let a=o.composedPath&&o.composedPath()[0]||o.target,s=t(a);s&&!e.completed.has(s)&&e.events.push([s,o])}))))})(_$HY={events:[],completed:new WeakSet,r:{},fe(){}});self._$=self._$||{P:function(s,f,p){return(p=new Promise(function(a,b){s=a,f=b})).s=s,p.f=f,p},uP:function(p){delete p.s;delete p.f},Ps:function(p,d){p.s(d),p.status="success",p.value=d,this.uP(p)},Pf:function(p,d){p.f(d),p.status="failure",p.value=d,this.uP(p)},uS:function(s){delete s.c},Se:function(s,t,d,c){switch(c=s.c,t){case 0:return c.enqueue(d);case 1:return(this.uS(s),c.error(d));case 2:return(this.uS(s),c.close())}},S:function(s,c){return(s=new ReadableStream({start:function(x){c=x}})).c=c,s}}</script><!--xs--><script type="module" async src="/assets/entry-client-503078e3.js"></script></body></html>