<!DOCTYPE html><html lang="en" ><head ><meta data-sm="0-0-0-0-0-0-0-0-0-0-1-0" charset="utf-8"/><meta data-sm="0-0-0-0-0-0-0-0-0-0-2-0" name="viewport" content="width=device-width, initial-scale=1"/><title data-sm="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-1-0">Research - Foo Yong Qi</title><link rel="modulepreload" href="/assets/research-c85ce5be.js"><link rel="modulepreload" href="/assets/entry-client-20e89e81.js"><link rel="stylesheet" href="/assets/entry-client-f1baca8c.css"><link rel="modulepreload" href="/assets/Tag-2306854b.js"><link rel="stylesheet" href="/assets/Tag-7bb03d3d.css"></head><body ><!--!$e0-0-0-0-0-0-0-0-0-1-0-0-0-0-0--><nav data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0"><div class="nav-bar"><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-1-0" link="true" href="/" class=" active" aria-current="page"><button data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-1-1" class="btn home"><svg class="home-svg" fill="currentColor" viewBox="0 0 75 65"><path d="M37.59.25l36.95 64H.64l36.95-64z"></path></svg></button></a><!--/--><div class="nav-grp"><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-2-0" link="true" href="/cv" class="inactive" ><button data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-2-1" class="btn">CV</button></a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-3-0" link="true" href="/teaching" class="inactive" ><button data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-3-1" class="btn">Teaching</button></a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-4-0" link="true" href="/research" class=" active" aria-current="page"><button data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-4-1" class="btn">Research</button></a><!--/--><a style="color:#CCCCCC" href="https://yongqi.foo/blog/"><button class="btn">Blog</button></a></div></div><div id="menuToggle"><input id="checkbox" type="checkbox"><label class="toggle" for="checkbox"><div class="bar bar--top"></div><div class="bar bar--middle"></div><div class="bar bar--bottom"></div><div id="nav-pane"><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-5-0" link="true" href="/" class="navitem active" aria-current="page">Home</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-6-0" link="true" href="/cv" class="navitem inactive" >CV</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-7-0" link="true" href="/teaching" class="navitem inactive" >Teaching</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-8-0" link="true" href="/research" class="navitem active" aria-current="page">Research</a><!--/--><a style="color:#CCCCCC" class="navitem" href="https://yongqi.foo/blog">Blog</a></div></label></div></nav><main data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-0"><!--$--><!--/--><div class="flex-row"><div class="box left-box"><h2>Reconstruction of Incomplete Polymorphic Programs</h2><p>The ability to reconstruct the dependencies of incomplete programs to form complete and well-typed ones provides several benefits, including allowing static analysis tools to analyse incomplete programs where their surrounding dependencies are unavailable, and supporting stub generation and testing tools to work on snippets. However, earlier efforts to do so are unable to work with incomplete programs containing parametrically polymorphic types. </p><p>In this paper, we present a technique that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. We then present empirical results from our prototype implementation of this algorithm, JavaCIP, which outperforms prior works in this area.</p><p><a href="../papers/javacip/Reconstruction of Incomplete Polymorphic Programs.pdf">Submitted Author's Copy (Under Review) </a> | <a href="../papers/javacip/Poster.pdf">Poster</a></p><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-0" class="tags"><em>Tags:</em> <!--$--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-1-0" class="tag">Type Systems</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-2-0" class="tag">Polymorphism</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-3-0" class="tag">Program Analysis</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-4-0" class="tag">Java</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-5-0" class="tag">Submitted</span><!--/--></div><!--/--></div><div class="box"><h2>Partial Evaluation of Rank-2 Polymorphic Functions</h2><p>Rank-2 polymorphic functions are used in a variety of programs and libraries. However, such functions may be difficult to optimize by general-purpose optimizers, especially if they are recursive. General-purpose optimizers thus avoid optimizing these functions, leaving many missed opportunities for further program optimization. </p><p> Thus, we propose a new optimization pass, PEPSA, that performs a partial evaluation of partially static applications of rank-2 polymorphic functions to reveal further avenues of optimization. Preliminary benchmarks show that PEPSA, in conjunction with other standard optimization passes, achieves a 3 to 75 times speedup on generic programming systems.</p><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-3-0" class="tags"><em>Tags:</em> <!--$--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-3-1-0" class="tag">Optimization</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-3-2-0" class="tag">Generic Programming</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-3-3-0" class="tag">Haskell</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-3-4-0" class="tag">Polymorphism</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-3-5-0" class="tag">In Progress (nearing completion)</span><!--/--></div><!--/--></div></div><div class="flex-row"><div class="box left-box"><h2>A Fixed-Point-Oriented Programming Language with User-Specified Optimization Strategies</h2><p>There are a wide range of problems that are easily solved using a fixed-point algorithm instead of the more common programming strategies of loops and recursions. Examples of these include parsing, static analysis, type-checking, graph algorithms, and automata manipulation. Existing language paradigms, such as the imperative and functional paradigms, support loops and recursions well but support fixed-point algorithms rather poorly.</p><p>In this project, we will develop a programming language providing such support. In addition, by specifying problems at the abstraction-level of fixed points, our language can include mechanisms for the programmer to influence and optimize the solution strategy used by the implementation without the programmer having to modify the problem specification. This will allow users of the language to rapidly prototype and test a problem specification and to later specify optimizations while making only minimal changes to existing code, a task particularly difficult for fixed-point problems in existing languages. </p><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-0" class="tags"><em>Tags:</em> <!--$--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-1-0" class="tag">Programming Paradigms</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-2-0" class="tag">Declarative Programming</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-3-0" class="tag">Fixed-Point-Oriented Programming</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-4-0" class="tag">Optimization</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-5-0" class="tag">In Progress (early)</span><!--/--></div><!--/--></div><div class="box"><h2>Optimization Tactics (Functional Pearl)</h2><p>Program optimizations are frequently done by the compiler. These optimizations are general purpose, so as to extract the best performance out of as many programs as possible. However, general-purpose optimizations may not be well-suited for some specific programs.</p><p>Thus, we present <strong>optimization tactics</strong>, a new construct that allows users to define their own optimization strategies and to apply optimizations at specific program points. The library for supporting optimization tactics is implemented with Lean 4's powerful metaprogramming and theorem proving facilities, which allows users to:</p><ul><li>Easily define provably correctness-preserving optimization tactics as expression-to-expression transformation functions.</li><li>Apply an optimization wherever a program term occurs</li><li>Leverage Lean 4's interactive view to observe every step of the optimization</li><li>Separate algorithm from optimization.</li></ul><p>Optimization tactics thus allows library authors to define domain-specific optimizations, and for library users to incorporate, extend and adapt optimization tactics to their specific use-case. We also propose that the interactivity of optimization tactics in Lean 4 allows researchers to explore new optimization techniques that can be applied to other functional programming languages.</p><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-5-0" class="tags"><em>Tags:</em> <!--$--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-5-1-0" class="tag">Optimization</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-5-2-0" class="tag">Metaprogramming</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-5-3-0" class="tag">Lean 4</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-5-4-0" class="tag">In Progress (early)</span><!--/--></div><!--/--></div></div><div class="flex-row"><div class="box left-box"><h2>Improving the Bounds on Random-Access Lists</h2><p>Accessing an arbitrary element of a traditional singly linked list or <tt>cons</tt> list requires traversing up to a linear number of pointers. A random-access list is a data structure that behaves like a <tt>cons</tt> list except that accessing an arbitrary element requires traversing only a logarithmic number of pointers. Specifically, in a list of length n, an arbitrary element can be accessed by traversing at most <tt>3 * ceil(log(n)) - 5</tt> pointers.</p><p>In this paper, we present a simple variation on Myers lists that improves this bound and requires traversing at most <tt>2 * ceil(log(n + 1)) - 1</tt> pointers. We then present a more complicated variation that improves this bound to <tt>(1 + 1 / s) * ceil(log(n)) + s + 9</tt> for any <tt>s &gt;= 2</tt>. This shows that it is possible to get asymptotically close to the information-theoretically optimal bound of <tt>ceil(log(n + 1)) - 1</tt>.</p><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-6-0" class="tags"><em>Tags:</em> <!--$--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-6-1-0" class="tag">Data Structures</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-6-2-0" class="tag">Functional Programming</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-6-3-0" class="tag">In Progress (nearing completion)</span><!--/--></div><!--/--></div><div class="box"><h2>Motivating Mathematics Study in Prospective Computer Scientists with Interactive Theorem Provers</h2><p>The Curry-Howard correspondence shows that terms, types, programs and program evaluation correspond to witnesses, propositions, proofs and proof normalization in (intuitionistic) logic. This has spawned a large body of work in the literature known as <em>proof assistants</em> or <em>interactive theorem provers</em> that exploit this correspondence via a programming language with a type system that supports proof checking.</p><p>On the other hand, the need to study mathematics may not be immediately apparent to budding software engineers, particularly those aiming to enter industry post-study. Our aim is motivate students to study mathematics by showing that the art of writing programs is the same as the art of writing a proof. We do so by writing both proofs and programs in Lean 4.</p><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-7-0" class="tags"><em>Tags:</em> <!--$--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-7-1-0" class="tag">Education</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-7-2-0" class="tag">In Progress (early)</span><!--/--></div><!--/--></div></div></main><!--!$/e0-0-0-0-0-0-0-0-0-1-0-0-0-0-0--><script>window._$HY||(e=>{let t=e=>e&&e.hasAttribute&&(e.hasAttribute("data-hk")?e:t(e.host&&e.host.nodeType?e.host:e.parentNode));["click", "input"].forEach((o=>document.addEventListener(o,(o=>{let a=o.composedPath&&o.composedPath()[0]||o.target,s=t(a);s&&!e.completed.has(s)&&e.events.push([s,o])}))))})(_$HY={events:[],completed:new WeakSet,r:{},fe(){}});self._$=self._$||{P:function(s,f,p){return(p=new Promise(function(a,b){s=a,f=b})).s=s,p.f=f,p},uP:function(p){delete p.s;delete p.f},Ps:function(p,d){p.s(d),p.status="success",p.value=d,this.uP(p)},Pf:function(p,d){p.f(d),p.status="failure",p.value=d,this.uP(p)},uS:function(s){delete s.c},Se:function(s,t,d,c){switch(c=s.c,t){case 0:return c.enqueue(d);case 1:return(this.uS(s),c.error(d));case 2:return(this.uS(s),c.close())}},S:function(s,c){return(s=new ReadableStream({start:function(x){c=x}})).c=c,s}}</script><!--xs--><script type="module" async src="/assets/entry-client-20e89e81.js"></script></body></html>