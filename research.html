<!DOCTYPE html><html lang="en" ><head ><meta data-sm="0-0-0-0-0-0-0-0-0-0-1-0" charset="utf-8"/><meta data-sm="0-0-0-0-0-0-0-0-0-0-2-0" name="viewport" content="width=device-width, initial-scale=1"/><title data-sm="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-1-0">Research - Foo Yong Qi</title><link rel="modulepreload" href="/assets/research-e0bafcb2.js"><link rel="modulepreload" href="/assets/entry-client-bae6aa3c.js"><link rel="stylesheet" href="/assets/entry-client-f1baca8c.css"><link rel="modulepreload" href="/assets/Tag-06a626fa.js"><link rel="stylesheet" href="/assets/Tag-7bb03d3d.css"></head><body ><!--!$e0-0-0-0-0-0-0-0-0-1-0-0-0-0-0--><nav data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-0"><div class="nav-bar"><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-1-0" link="true" href="/" class=" active" aria-current="page"><button data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-1-1" class="btn home"><svg class="home-svg" fill="currentColor" viewBox="0 0 75 65"><path d="M37.59.25l36.95 64H.64l36.95-64z"></path></svg></button></a><!--/--><div class="nav-grp"><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-2-0" link="true" href="/cv" class="inactive" ><button data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-2-1" class="btn">CV</button></a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-3-0" link="true" href="/teaching" class="inactive" ><button data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-3-1" class="btn">Teaching</button></a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-4-0" link="true" href="/research" class=" active" aria-current="page"><button data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-4-1" class="btn">Research</button></a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-5-0" link="true" href="https://yongqi.foo/blog/" class="inactive" ><button data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-5-1" class="btn">Blog</button></a><!--/--></div></div><div id="menuToggle"><input id="checkbox" type="checkbox"><label class="toggle" for="checkbox"><div class="bar bar--top"></div><div class="bar bar--middle"></div><div class="bar bar--bottom"></div><div id="nav-pane"><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-6-0" link="true" href="/" class="navitem active" aria-current="page">Home</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-7-0" link="true" href="/cv" class="navitem inactive" >CV</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-8-0" link="true" href="/teaching" class="navitem inactive" >Teaching</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-9-0" link="true" href="/research" class="navitem active" aria-current="page">Research</a><!--/--><!--$--><a data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-0-10-0" link="true" href="https://yongqi.foo/blog" class="navitem inactive" >Blog</a><!--/--></div></label></div></nav><main data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-0"><!--$--><!--/--><div class="flex-row"><div class="box left-box"><h2>Reconstruction of Incomplete Polymorphic Programs</h2><p>The ability to reconstruct the dependencies of incomplete programs to form complete and well-typed ones provides several benefits, including allowing static analysis tools to analyse incomplete programs where their surrounding dependencies are unavailable, and supporting stub generation and testing tools to work on snippets. However, earlier efforts to do so are unable to work with incomplete programs containing parametrically polymorphic types. </p><p>In this paper, we present a technique that receives an incomplete Java program that may contain parametrically polymorphic types, and reconstructs its surrounding dependencies to form a complete and well-typed program. We then present empirical results from our prototype implementation of this algorithm, JavaCIP, which outperforms prior works in this area.</p><p><a href="../papers/javacip/Reconstruction of Incomplete Polymorphic Programs.pdf">Submitted Author's Copy (Under Review) </a> | <a href="../papers/javacip/Poster.pdf">Poster</a></p><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-0" class="tags"><em>Tags:</em> <!--$--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-1-0" class="tag">Type Systems</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-2-0" class="tag">Polymorphism</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-3-0" class="tag">Program Analysis</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-4-0" class="tag">Java</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-2-5-0" class="tag">Submitted</span><!--/--></div><!--/--></div><div class="box"><h2>Motivating Mathematics Study in Prospective Computer Scientists with Interactive Theorem Provers</h2><p>The Curry-Howard correspondence shows that terms, types, programs and program evaluation correspond to witnesses, propositions, proofs and proof normalization in (intuitionistic) logic. This has spawned a large body of work in the literature known as <em>proof assistants</em> or <em>interactive theorem provers</em> that exploit this correspondence via a programming language with a type system that supports proof checking.</p><p>On the other hand, the need to study mathematics may not be immediately apparent to budding software engineers, particularly those aiming to enter industry post-study. Our aim is motivate students to study mathematics by showing that the art of writing programs is the same as the art of writing a proof. We do so by writing both proofs and programs in Lean 4.</p><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-3-0" class="tags"><em>Tags:</em> <!--$--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-3-1-0" class="tag">Education</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-3-2-0" class="tag">In Progress (early)</span><!--/--></div><!--/--></div></div><div class="box solo"><h2>Optimizing SYB Traversals via Specialization</h2><p>Scrap Your Boilerplate (SYB) supports generic traversals to eliminate boilerplate code, but suffers from poor performance. While there have been attempts to optimize uses of SYB, some require a rewrite of code, or the optimizations themselves run slowly.</p><p>We show that with new forms of specialization, we are able to optimize SYB traversals quickly and effectively.</p><!--$--><div data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-0" class="tags"><em>Tags:</em> <!--$--><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-1-0" class="tag">Generic Programming</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-2-0" class="tag">Scrap Your Boilerplate</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-3-0" class="tag">Haskell</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-4-0" class="tag">Polymorphism</span><span data-hk="0-0-0-0-0-0-0-0-0-1-0-0-0-0-1-1-0-0-4-5-0" class="tag">In Progress (early)</span><!--/--></div><!--/--></div></main><!--!$/e0-0-0-0-0-0-0-0-0-1-0-0-0-0-0--><script>window._$HY||(e=>{let t=e=>e&&e.hasAttribute&&(e.hasAttribute("data-hk")?e:t(e.host&&e.host.nodeType?e.host:e.parentNode));["click", "input"].forEach((o=>document.addEventListener(o,(o=>{let a=o.composedPath&&o.composedPath()[0]||o.target,s=t(a);s&&!e.completed.has(s)&&e.events.push([s,o])}))))})(_$HY={events:[],completed:new WeakSet,r:{},fe(){}});self._$=self._$||{P:function(s,f,p){return(p=new Promise(function(a,b){s=a,f=b})).s=s,p.f=f,p},uP:function(p){delete p.s;delete p.f},Ps:function(p,d){p.s(d),p.status="success",p.value=d,this.uP(p)},Pf:function(p,d){p.f(d),p.status="failure",p.value=d,this.uP(p)},uS:function(s){delete s.c},Se:function(s,t,d,c){switch(c=s.c,t){case 0:return c.enqueue(d);case 1:return(this.uS(s),c.error(d));case 2:return(this.uS(s),c.close())}},S:function(s,c){return(s=new ReadableStream({start:function(x){c=x}})).c=c,s}}</script><!--xs--><script type="module" async src="/assets/entry-client-bae6aa3c.js"></script></body></html>